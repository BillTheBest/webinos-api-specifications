/**<p>Interface for exchanging messages between applications, both locally or remotely.</p>
 * \name App2App Messaging API
 *
 * The Webinos App2App Messaging specification defines interfaces
 * to create, send and receive messages between applications in the Webinos
 * system. It provides generic messaging primitives which can be applied
 * in different application scenarios. The messaging is <em>indirect</em>, 
 * meaning that applications do not directly address each other but use a
 * channel to route the messages to connected applications. An unique namespace
 * (within a personal zone) is used as a key to find and connect to channels.
 *
 * This API can be used by third-party application
 * developers to implement custom message-based protocols by taking advantage of
 * the features offered by the Webinos message handling system and overlay
 * networking model.
 *
 * \def-api-feature http://webinos.org/api/app2app
 * \author Fabian Walraven &lt;fabian.walraven@tno.nl&gt;
 * \version 0.1.1
 */

/**
 * \brief The App2AppMessaging interface describes the part of the
 *        App2App Messaging API accessible through the
 *        webinos object.
 */
partial interface Webinos {
  /**
   * \brief webinos.app2app object.
   */
  readonly attribute App2AppMessaging app2app;
};

/**
 * \brief Access to the App2App Messaging functions.
 *
 * An application
 * can create and configure a channel using a namespace. Other applications are
 * able to
 * connect to that channel using the namespace as a key (with a possible 
 * wildcard). A channel sits between (two or more) applications such that
 * applications do not address each other directly.
 *
 * Optionally, the application which created the channel (i.e. the channel owner)
 * can authorize connect requests of other application instances that want to use
 * the channel using the App2AppChannelRequestCB callback.
 */
interface App2AppMessaging {

  /**
   * \brief Create a new message.
   *
   * \param type The type of the message.
   * \param payload The payload of the message.
   */
  App2AppMessage createMessage(
    DOMString type,
    [TreatUndefinedAs=Null] 
      optional DOMString? payload);

  /**
   * \brief Create a new channel.
   *
   * \param namespace The namespace of the channel (must be unique within the
   * personal zone.
   * \param properties The properties of the channel.
   * \param requestCB The callback called when an application wants to connect
   * to the channel. If the callback returns true the application is allowed to
   * connect, otherwise the connect attempt is rejected.
   */
  App2AppChannel createChannel(
    DOMString namespace,
    App2AppChannelProperties properties,
    optional App2AppChannelRequestCB requestCB);

  /**
   * \brief Search for channels.
   *
   * The key used for finding channels is the channel namespace. It is possible
   * to use a trailing wildcard for the namespace-specific string of the URN to
   * match all channels with the provided namespace identifier prefix. This is
   * useful when multiple application instances of the same application run in
   * the personal zone, share the same namespace identifier and use a generated
   * namespace-specific string to avoid clashes.
   *
   * \param namespace The namespace of the channels to search for. A wildcard
   * is allowed for the namespace-specific string.
   * \param zoneIds The identifiers of the personal zones to search for
   * channels in addition the local personal zone.
   * \param searchCB The callback called when the search is complete.
   * \return PendingOperation interface to cancel the asynchronous call.
   */
  PendingOperation searchForChannels(
    DOMString namespace, 
    DOMString[] zoneIds,
    App2AppChannelSearchCB searchCB,
    optional App2AppErrorCB errorCB);

};

/**
 * \brief The App2AppMessage interface.
 */
dictionary App2AppMessage {

  /**
   * \brief The identifier of the message.
   *
   * The message identifier is generated by the Webinos system.
   */
  DOMString id;

  /**
   * \brief The message type.
   */
  DOMString type;

  /**
   * \brief The timestamp of the message.
   *
   * The message timestamp is generated by the Webinos system.
   */
  DOMTimeStamp timeStamp;

  /**
   * \brief The payload of the message.
   */
  DOMString? payload;
};

/**
 * \brief The App2AppChannel interface.
 *
 * A channel is the primary entity used for App2App Messaging.
 * The namespace of a channel is specified as an URN and must be unique within
 * a personal zone. If an application attempts to create a channel with an 
 * already existing namespace (i.e. there is already an active channel with
 * the same namespace within the personal zone) an error is returned.
 *
 * An application can create multiple channels, if needed. Each channel
 * requires its own namespace.
 */
interface App2AppChannel {

  /**
   * \brief The namespace of the channel.
   */
  readonly attribute DOMString namespace;

  /**
   * \brief The properties of the channel.
   */
  readonly attribute App2AppChannelProperties properties;

  /**
   * \brief Connects to the channel.
   *
   * \param request Request object to include in the request.
   * \param messageCB Callback called when receiving a message.
   * \param successCB Callback called when the connect was successful.
   * \param errorCB Callback called when an error occurred during connecting.
   */
  void connect(
    App2AppChannelRequest request,
    App2AppMessageCB messageCB,
    optional App2AppSuccessCB successCB,
    optional App2AppErrorCB errorCB);

  /**
   * \brief Send a message on the channel.
   *
   * \param message The message to send.
   * \param errorCB Callback called when an error occurred during sending.
   */
  void send(
    App2AppMessage message,
    optional App2AppErrorCB errorCB);

  /**
   * \brief Close the channel.
   *
   * There is no correspoing open function as this is implicit in the
   * creation of the channel.
   */
  void close();
};

/**
 * \brief The channel properties.
 *
 * At channel creation time the application instance can specify channel
 * properties. The properties contains mandatory fields but can be extended
 * with application-specific fields.
 */
dictionary App2AppChannelProperties {

  /**
   * \brief The owner of the channel.
   */
  DOMString channelOwner;

  /**
   * \brief The mode of the channel.
   */
  ChannelMode mode;
};

/**
 * \brief The available channel modes.
 *
 * <ul>
 *   <li>send-receive: connected applications can both send and receive on the
 *   channel. This is effectively a many-to-many communication scheme.</li>
 *   <li>receive-only: connected applications can only receive on the channel
 *     (the channel owner can both send and receive). This is effectively a
 *     one-to-many communication scheme.</li>
 *   <li>p2p: at most two applications can connect to the channel which 
 *     uses peer-to-peer routing (i.e. without involving a PZH for
 *     routing messages).</li>
 * </ul>
 */
enum ChannelMode { "send-receive", "receive-only", "p2p" };

/**
 * \brief Interface for channel connect requests.
 */
dictionary App2AppChannelRequest {

  /**
   * \brief The source of the channel request.
   */
  DOMString source;
};

/**
 * \brief The request callback for authorizing channel connection attempts.
 */
callback App2AppChannelRequestCB = boolean (App2AppChannelRequest request);

/**
 * \brief Pending operation interface for cancelling asynchronous calls.
 */
[NoInterfaceObject] interface PendingOperation {
  void cancel();
};

/**
 * \brief Success callback for when an operation successfully terminated.
 */
callback App2AppSuccessCB = void ();

/**
 * \brief Error callback for errors when interacting with a channel.
 */
callback App2AppErrorCB = void (DOMError error);

/**
 * \brief The channel search callback.
 */
callback App2AppChannelSearchCB = void (App2AppChannel[] channels);

