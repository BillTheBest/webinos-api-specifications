/**
 * \brief The Service Discovery API 
 *
 * The Webinos Service Discovery API provide web applications with 
 * an API to find and bind to services that are exposed in a personal zone of devices.
 * Service Discovery can be used to find services that are exposed in a personal zone
 * or via legacy discovery methods, e.g. Bluetooth service discovery, UPnP, USB
 * or DNS-SD. The discovery process is not limited to services available via 
 * local connectivity bearers. It is also possible remote services. 
 * 
 * The api assumes that the web application is installed, trusted and that the user is
 * authenticated/authorized to use the api.
 *
 * \def-api-feature http://webinos.org/api/servicediscovery
 * \author Anders Isberg &lt;anders.isberg@sonyericsson.com&gt;
 * \version 0.5 
 */
module serviceDiscovery {
	/**
	 * \brief The ServiceDiscoveryManager interface provides functionality for service discovery. 
	 * The API supports the possibility to find services based on a given service type either in 
	 * a personal zone of devices or via other legacy discovery methods. When searching for a service type
	 * the operation can be restricted by providing certain constraints and/or context information.  
	 *
	 * The code example below shows how an application initiates a search query
	 * to find a geolocation service. On each success callback a new selection item
	 * is added to the option list, whilst new services are discovered. Once the user
	 * selects a service, the usage of the service authorized and an implementation of
	 * the API is instantiated.  
	 * \code
	var findHandle = 0;
	var serviceHandle = 0;
	var geoServices = {};
	
	// Success callback that displays a list of found services in a HTML selection list
	// The selection list is dynamically extended every time a new service is discovered.	
	function serviceFoundCB(service) {	
		var selectlist = document.getElementById('servicelist');
		var option = document.createElement('option');
	
		option.value = service.id;
		option.appendChild(document.createTextNode(service.displayName));
		geoServices[service.id] = service;
		selectlist.appendChild(option);
	}
	
	// Success callback when bind has been successfully executed on the service object. 
	function successCB(myLocationService) {
		alert('Service ' + myLocationService.displayName + ' ready to use');
		myLocationService.getCurrentPosition(showMap);
	}
	
	// Select callback method that is invoked when user selects an option in the selection list 
	function serviceSelected(service) {
	
		// Stops the findServices operation
		findHandle.cancel();
	
		// Binds to the service to initiate an authorized object used to
		// invoke services.  
		serviceHandle = service.bind(successCB);
	}
	
	// Initiate a search query for a service of the type geolocation
	findHandle = window.webinos.findServices('self', {api:'http://webinos.org/api/geolocation'}, serviceFoundCB);
	
	var selectlist = document.getElementById('servicelist');
	selectlist.addEventListener("change", function (e) {
		var service = geoServices[e.target.value];
		if (service) {
			serviceSelected(service);
		}
	}, false);
	 * \endcode
	 *
	 */
	[NoInterfaceObject] interface ServiceDiscoveryManager  {
		/**
		 * \brief The findServices method initiates an asynchronous search query for services matching the requested zoneId, serviceType and filter parameters. The method continues to execute until the findService method is canceled by the application or when maximum search timer expires.     
		 * The zones in which services are to be searched are expected to be managed by the Webinos runtime engine (rather than the application developer). As an example on how this zone management can be presented by a runtime engine, see a possible infobar (at http://dev.webinos.org/specifications/draft/infobar.png )  that would lead to a personal zones management UI (http://dev.webinos.org/specifications/draft/pz-add-ui.png )
		 * \param zoneId Identity of a Personal Zone that is hosting the service. The zoneId 'self' is reserved for the Personal Zone of the user authenticated against the device. The zoneId 'shared' is reserved for services that are shared on the current network.
		 * \param serviceType An input argument that defines which type of service that is requested.
		 * \param successCallBack Callback issued every time a service is found matching search criteria.  The callback is called every time a new service is found matching the zoneId, serviceType and filter.
		 * \param errorCallBack Callback issued if service discovery fails.  
		 * \param options Defines search options. 
		 * \param filter Defines a filter that be used to limit the service operation to certain constraints and context information. 
		 * \throw DiscoveryExceptions 
		 */
		 PendingOperation findServices(in DOMString zoneId, in ServiceType serviceType, in SuccessCallBack successCallBack, in optional ErrorCallBack errorCallBack, in optional Options options, in optional Filter filter)
		 raises(DiscoveryExceptions);		 
	};
		
	/**
	 * \brief The Service Type interface is used to define which type of service that is requested. 
	 */
	[NoInterfaceObject] interface ServiceType {
		/**
	 	 * \brief URI used to identify the requested API's feature set. The URI shall be globally unique.  
		 */
		attribute DOMString api;
	};
		
	/**
	 * \brief SuccessCallBack interface definition
	 */
	[Callback=FunctionOnly, NoInterfaceObject] interface SuccessCallBack {
		/**
		 * \brief Asynchronous success callback.      
		 * \param service An input argument representing the discovered service.
		 */
		 void onSuccess(in Service service);	  
	};
	
	/**
	 * \brief ErrorCallBack interface definition
	 */
	[Callback=FunctionOnly, NoInterfaceObject] interface ErrorCallBack {
		/**
		 * \brief Asynchronous error callback.   
		 * \param error Error code. 
		 */
		void onErrror(in DiscoveryError error); 
	};

	/**
	 * \brief Service interface provides an API to bind to a specific service and monitoring
	 * the current state of the service in an asynchronous manner. The process of binding
	 * to a service involves:
	 * 1. mutual authentication between the service and the personal zone
	 * 2. in case of cross zone interworking, mutual authentication between the zones
	 * 3. agreement on data handling obligations as set out in the service's privacy policy
	 * 4. verifying access privileges and checks the need for elevated privileges
	 * 5. instantiate an implementation of the api that can be used by applications to request services from the requested API.
	 */
	
	interface Service {
		/**
		 * \brief A constant describing the service is in the process of binding to the service. 
		 */
		const unsigned short SERVICE_INITATING = 0;		
		/**
		 * \brief A constant describing the service is available and is ready to be used by the application.  
		 */	 	 
		const unsigned short SERVICE_AVAILABLE = 1;
		/**
		 * \brief A constant describing the service is unavailable. 
		 */
		const unsigned short SERVICE_UNAVAILABLE = 2;
		/**
		 * \brief Current service state of the Service. 
		 */
		readonly attribute unsigned short state;
		/**
	 	 * \brief API is a global unique URI identifying the feature set provided when the bind has been successfully executed.
	 	 */
		attribute DOMString api;
		/**
		 * \brief Id is a globally unique id representing the binding to the service. The id can be used
		 * to resume the binding again to the service without invoking the 
		 * findServices process again. 
		 */
		attribute DOMString id;
		/**
		 * \brief A human readable name of the service. 
		 */
		attribute DOMString displayName;
		/**
		 * \brief An URL referring to a detailed description of the service. 
		 */ 
		attribute DOMString? description;
		/**
		 * \brief bind Binds to the service uniquely identified by the service identity.  
		 * \param successCallBack Callback issued if a service is found.  The callback is called every time a new service is found matching the zoneId, serviceType and filter.
		 * \param errorCallBack Callback issued if serviceDiscovery fails.  
		 * \param serviceId Unique id of the binding to the particular service. If no serviceId is provided as an in parameter, the id attribute in the Service interface will be used to bind the service.
		 * \throw DiscoveryExceptions
		 */
		PendingOperation bind(in BindSuccessCallBack successCallBack, in optional BindErrorCallBack errorCallBack, in optional DOMString serviceId)
		raises(DiscoveryExceptions);
		
		/**
		 * \brief unbind Releases all resources and connections allocated by the service object.  
		 * \throw DiscoveryExceptions
		 */
		void unbind()
		raises(DiscoveryExceptions);
	};
	
	/**
	 * \brief Bind success callback interface definition
	 */
	[Callback=FunctionOnly, NoInterfaceObject] interface BindSuccessCallBack {
		/**
		 * \brief Asynchronous success callback.      
		 * \param service An input argument representing the service.
		 */
		 void onSuccess(in Service service);
		/**
		 * \brief Asynchronous callback indicating that the service is available again      
		 */		 
		 void onServiceAvailable();
	};
	
	/**
	 * \brief Bind error callback interface definition
	 */
	[Callback=FunctionOnly, NoInterfaceObject] interface BindErrorCallBack {
		/**
		 * \brief Asynchronous error callback.   
		 * \param error Error code. 
		 */
		void onErrror(in DiscoveryError error); 
		/**
		 * \brief Asynchronous indicating the service is temporarily unavailable.
		 */		 		 
		 void onServiceUnavailable();	  
	};
	
	
	/**
	 * \brief Option interface definition
   	 */
	[NoInterfaceObject] interface Options {
		/**
		 * \brief INFINITE Timeout Value
		 */
		const unsigned short INFINITE = 0;		
		/**
		 * \brief A timeout value for the findService operation in seconds between 0-65535. Default value is 120 seconds.
		 */
		attribute unsigned short timeout;
	};
	
	/**
	* \brief TBD: Some nice attributes to express filters. 
	*/
	[NoInterfaceObject] interface Filter {
	 
	};
	
	/**
	 * \brief Pending Operation interface 
	 */
	[NoInterfaceObject] interface PendingOperation {
		/**
		 * \brief Cancels the pending asynchronous operation and allocated resources are released.  
		 */
		void cancel();
	};
  
	/**
	 * \brief Discovery specific errors.
	 */
	[NoInterfaceObject] interface DiscoveryError {
		/**
		 * \brief The discovery process was canceled by the application
		 */
		 const unsigned short FIND_SERVICE_CANCELED = 101;
		/**
		 * \brief The discovery process was canceled since the timeout timer expired. 
		 */
		 const unsigned short FIND_SERVICE_TIMEOUT = 102;		 
		/**
		 * \brief Not Authorized to use the service.  
		 */
		 const unsigned short NOT_AUTHORIZED = 103;
	};
  
	/**
	 * \brief Discovery specific exceptions.
	 */
	exception DiscoveryExceptions {
		/**
		 * \brief The property cannot be currently retrieved
		 */
		 const unsigned short INVALID_ARGUMENT_ERROR = 101;
	};
};
