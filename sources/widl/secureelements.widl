/**<p>The webinos Secure Elements API provides access to functions on contact or contactless smart cards or similar devices.</p>
 * \name Secure Elements API
 *
 * This is an API for accessing functions on contact or contactless smart cards or similar devices using the Application Protocol Data Unit (APDU) command response protocol, as defined by ISO 7816-4. In essence, the command consists of a 4 byte header followed by up to 255 bytes of data. The response contains a 2 byte header followed by up to 256 bytes of data. The headers and data are specified in a suite of standards from ISO and others. It also possible to develop custom secure elements using Java cards from companies such as G&D and Gemalto.
 * 
 * The aim is to give system applications written in JavaScript, and executing on a web run-time, a lightweight means to send commands to secure elements and handle the responses using byte arrays (similar to the existing Java API). Applications would have access to the crypto APIs being developed in the W3C Web Crypto WG.
 * 
 * A brief introduction to APDU can be found at:
 * http://en.wikipedia.org/wiki/Smart_card_application_protocol_data_unit
 * The Java APDU API is described at:
 * http://docs.oracle.com/javase/6/docs/jre/api/security/smartcardio/spec/
 * Should consider alternative API design patterns, e.g. node error model
 * 
 * http://darobin.github.com/api-design-cookbook/
 * Implementation
 * There are two main options:
 * 
 * USB smart card reader for contact based cards
 * NFC based reader for contactless cards
 * Java Smart Card development kits are available, and this would involve interfacing Node with Java. The open source cross platform NFC library libnfc can be used to access smart cards over NFC, but involves a lot of low level details. A further idea is to use the Java SmartCard API on Android, see:
 * 
 * Secure Element Evaluation Kit for the Android platform
 * It appears that the Nexus S should work with that for UICC smart card development. However, the above page states that the minimum required SDK is API15 (Android 4.03) which is yet to be supported for the webinos Android build. However, it seems very promising as a basis for demo purposes. We would also need some sample smart cards with some interesting applets on them, although we could in principle develop our own applets.
 *
 * \def-api-feature http://webinos.org/api/secureelements
 * Identifies the Secure Elements API. 
 *
 * \author Dave Raggett (W3C) &lt;dsr@w3.org&gt;
 * \version 0.1
 *
 */
 
 /*
 *
 * \code
  
  // The first step is to obtain a list of available APDU terminals:
  
  
  Webinos.apdu.requestTerminals(listener, success, fail);

  function success ()
  {
    console.log("Request for APDU terminals succeeded");
  }

  function fail (why)
  {
    console.log("Requested for APDU terminals failed: " + why);
  }

  function listen (terminals)
  {
    for (var i = 0; i < terminals.length; ++i)
    {
      var terminal = terminals[i];
      console.log("found APDU terminal: " + terminal.name);
    }
  }

  // Having picked a terminal you can now connect to the card: 

  terminal.connect(success, fail);

  function success ()
  {
    console.log("connected to card");
  }

  function fail (why)
  {
    console.log("couldn't connect to card: " + why);
  }

  // Once connected you can format a command, send it to the card, and process the response:
 
  var command = terminal.createCommand();

  // initialize header bytes
  command.setHeaders(cla, ins, p1, p2);

  // set payload from byte array
  command.setPayload(payload);
 
  // and send it to the card
  terminal.transmit(command, success, fail);

  // handle the response
  function success (response)
  {
    console.log("response status: " + to_hex(response.status) +
                " with " + response.payload.length + " bytes of data");

    // when done, disconnect
    terminal.disconnect();
  }

  // called if transmit failed
  function fail (why)
  {
    console.log("couldn't transmit command to card: " + why);
  }
  
 * \endcode
 */   

/**
 * \brief The APDU interface is accessible through the webinos object.
 * 
 * You first need to find which terminals are available. Having found a suitable terminal, you can then test if a card is present, and connect to it, \n
 * and then transmit a command and process the response, before closing the connection. Call backs are provided to signal when cards are inserted and removed.
 */
partial interface Webinos {
  readonly attribute APDU apdu;
};

/**
* \brief Interface to request list of APDU terminals
*/
interface APDU {
  /**
  * \brief TODO Dave
  * \param listener TODO Dave
  * \param success TODO Dave
  * \param fail TODO Dave
  */
  void requestTerminals(ApduTerminalsCB listener,
                        SuccessCB success, FailCB fail);
};

/**
* \brief Call back for list of available terminals
*/
callback ApduTerminalsCB = void (ApduTerminal[] terminals);

/**
* \brief call back if associated request has succeeded
*/
callback SuccessCB = void ();

/**
* \brief call back if associated request has failed
*/
callback FailCB = void (DOMString why);

/**
* \brief The properties and methods for terminals. The terminal status present property indicates whether a card is present, and you can also set handlers for call backs when the card is inserted or removed.
*/
interface ApduTerminal {
  /**
  * \brief each terminal has a name
  */
  readonly attribute DOMString name;

  /**
  * \brief whether a card is present in the reader
  */
  readonly attribute boolean present;  

  /**
  * \brief call back for card insertion
  */
  attribute ApduCardInsertedCB inserted;
  
  /**
  * \brief call back for card insertion removal
  */  
  attribute ApduCardRemovedCB removed;


  /**
  * \brief TODO Dave
  *
  * \return TODO Dave
  */
  ApduCommand createCommand();
  
  
  /**
  * \brief TODO Dave
  * \param command TODO Dave
  * \param success TODO Dave
  * \param fail TODO Dave
  * 
  */
  void transmit(ApduCommand command,
                ApduResponseCB success, FailCB fail);

  /**
  * \brief TODO Dave
  * \param success TODO Dave
  * \param fail TODO Dave
  * 
  */
  void connect(SuccessCB success, FailCB fail);
  
  /**
  * \brief TODO Dave
  * 
  */ 
  void disconnect();
};

/**
* \brief Call back notifying when card is inserted. Will be called immediately if the card is already present.
*/
callback ApduCardInsertedCB = void ();

/**
* \brief Call back notifying when card is removed.
*/
callback ApduCardRemovedCB = void ();

/**
* \brief Call back for APDU response
*/
callback ApduResponseCB = void (ApduResponse response);

/**
* \brief This intferface defines ...TODO Dave
*/
interface ApduResponse {

  /**
  * \brief the 2 status bytes
  */
  attribute unsigned short status; 
  
  /**
  * \brief TODO Dave
  */  
  attribute byte[] payload;
};

/**
* \brief This intferface defines ...TODO Dave
*/
interface ApduCommand {
  /**
  * \brief TODO Dave
  * \param cla TODO Dave
  * \param ins TODO Dave 
  * \param p1 TODO Dave 
  * \param p2 TODO Dave    
  */  
  void setHeaders(byte cla, byte ins, byte p1, byte p2);
  
  /**
  * \brief TODO Dave
  * \param payload TODO Dave
  */  
  void setPayload(byte[] payload);
  
  /**
  * \brief TODO Dave
  * \param length TODO Dave  
  */  
  void setResponseLength(unsigned short length);
};