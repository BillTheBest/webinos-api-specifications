/**<p>The webinos The Device Interaction API allow you to control various components in the device. </p>
 * \name Device Interaction API 
 *
 *  This module provides a mechanism to interact with the end-user through features such as:
 *  \n    device vibrator,
 *  \n    device notifier,
 *  \n    screen backlight,
 *  \n    device Wallpaper.
 *
 * All the functionality of this module is accessed through the object deviceapis.deviceinteraction which is an instance of the DeviceInteractionManager interface. In case any functionality is not supported, a DOMException exception will be thrown with code NOT_SUPPORTED_ERR when the related method of the DeviceInteractionManager interface is invoked.
 *   
 * http://wacapps.net/api/deviceinteraction
 * 
 * Allows access to the device interaction module 
 *
 * \author WAC Device API Specifications 2.1, 30 April 2012
 * \author Normative: <a href="http://specs.wacapps.net/deviceinteraction/index.html">WAC Device Interaction API </a>
 * \author WIDL version for webinos created by Christian Fuhrhop &lt;christian.fuhrhop@fokus.fraunhofer.de&gt;
 * \version 2.1
 */
 
 
/**
 * \brief There will be a deviceapis.deviceinteraction object that allows accessing the functionality of the deviceinteraction module. 
 */
interface DeviceapisDeviceInteractionManager {
    readonly attribute DeviceInteractionManager deviceinteraction;
};
 
Deviceapis implements DeviceapisDeviceInteractionManager;
/**
 * \brief This is the top-level interface for the deviceinteraction API that provides access to the module functionalities.
 *
 * Example
 * \code
var di = deviceapis.deviceinteraction;

di.lightOn(function() {
	console.log("Lighting for 1 second");
},
function() {
	console.log("Failed to light");
},
1000);

di.startNotify(
function() {
	console.log("Notifying for 1 second");
},
function() {
	console.log("Failed to notify");
},
1000);

di.startVibrate(
function() {
	console.log("Vibrating for 1 second");
},
function() {
	console.log("Failed to vibrate");
},
1000);
 * \endcode
 */

interface DeviceInteractionManager {
    void startNotify(Function successCallback,
	                              optional ErrorCB? errorCallback
 	                              long duration) ;

    void startVibrate(Function successCallback,
                                  optional ErrorCB? errorCallback
                                  optional unsinged long duration,
                                  optional DOMString pattern);

    void lightOn(Function successCallback,
	                          optional ErrorCB? errorCallback
                            long duration);

    void setWallpaper(Function successCallback,
                                  optional ErrorCB? errorCallback
                                  DOMString fileName);
    void stopNotify();
    void stopVibrate();
    void lightOff();
};

 [NoInterfaceObject]
interface DeviceapisDeviceStatusManager {
       /**
        * \brief The devicestatus attribute provides access to Device Status API. 
        *         Example
        * \code
var info = deviceapis.devicestatus;
info.getPropertyValue(
function(model) {
	console.log("Device model is: " + model);
},
null, {
	aspect: "Device",
	property: "model"
});
        * \endcode
        */
    readonly attribute  DeviceStatusManager devicestatus;
};

       /**
        * \brief This offers methods to get information about the device status and subscribe to receive notifications of device status changes. To allow for asynchornous notification of changes to the various properties of components, the user agent keeps a list of active watch operations. Each entry in this list is identified by a number, which is unique within its list for the lifetime of the application.
        *         Example
        * \code
deviceapis.devicestatus.getPropertyValue(
function(value) {
	console.log("The battery level is at " + value + "%");
},
null, {
	property: "batteryLevel",
	aspect: "Battery"
});
        * \endcode
        */

[NoInterfaceObject]
interface DeviceStatusManager {
       /**
        * \brief The getComponents() method provides means to get the components of an aspect.
        * 
        * When the getComponents() method is invoked, the user agent MUST run the steps to retrieve the components.
        * steps to retrieve the components
        * 
        * The steps to retrieve the components are given by the following algorithm. The algorithm returns an array of component names, which may be empty.
        * 
        * \n  1. Run the general invocation checks algorithm. If no exceptions were generated, continue.
        * \n  2. Let components be an empty array.
        * \n  3. If the first argument (aspect) null, return components and terminate this algorithm.
        * \n  4. Let trimmed aspect be the result of trimming any space characters from the front and back of aspect.
        * \n  5. If trimmed aspect is an empty string or does not exactly match the name of a supported aspect, return null and terminate this algorithm.
        * \n  6. If trimmed aspect exactly matches the name of a supported aspect:
        * \n      6a. For each component of the matching aspect, create a DOMString representation of the component name and add it to the components array.
        * \n  7.  This offers methods to get information about the device status and subscribe to receive notifications of device status changes. To allow for asynchornous notification of changes to the various properties of components, the user agent keeps a list of active watch operations. Each entry in this list is identified by a number, which is unique within its list for the lifetime of the application.
        *         Example
        * \code
//displays contain, for example, ["screen1"] 
var displays = deviceapis.devicestatus.getComponents('Display');
console.log("Your device has " + displays.length + " displays");

//iterate through and show the name of each component
for (var i = 0; i < displays.length; i++) {
	var display = displays[i];
	console.log("Display component " + i + ": " + displays[i]);
}
        * \endcode
        * \param aspect for component to retrieve
        * \return components
        */
    DOMString[]? getComponents(DOMString? aspect);

       /**
        * \brief The isSupported() method checks if an aspect is supported and, optionally, if a property that would correspond to a component of that aspect is supported (e.g., a Battery aspect's batteryLevel property).
        * 
        * When invoked, the user agent MUST run the steps to check if an aspect is supported.
        * Steps to check if an aspect is supported
        * 
        * The steps to check if an aspect is supported are given by the following algorithm. The algorithm returns either true or false.
        * 
        * \n 1. Run the general invocation checks algorithm. If no exceptions were generated, continue.
        * \n 2. Let trimmed aspect be the result of trimming all white space from the front and back of the first argument.
        * \n 3. If the user agent does not supports aspect trimmed aspect, return false and terminate this algorithm.
        * \n 4. If the second argument (property) was passed, and it's not null,
        * \n    4a. Let trimmed property be the result of of trimming all white space from the front and back of the second argument.
        * \n    4b. If trimmed property is a supported property of trimmed aspect, then return true and terminate this algorithm.
        * \n 5. Return false.
        * 
        * Example
        * \code
if (deviceapis.devicestatus.isSupported('Battery', 'batteryLevel')) {
	console.log("batteryLevel property is available");
} else {
	console.log("batteryLevel property is not available");
}
        * \endcode
        * \param aspect Aspect to check for
        * \param aspect Optional property to check for
        * \return whether aspect is supported
        */
               
    boolean isSupported(
               DOMString aspect,
               optional DOMString? property);

       /**
        * \brief The getPropertyValue() method asyncrhonously attemps to read the value of a given component. However, if no component is given, the user agent will befault to the active component or the default component of a given aspect.
        * 
        * 
        * The steps to get a property value are given by the following algorithm:
        * 
        * \n  1. Run the general invocation checks algorithm. If no exceptions were generated, continue.
        * \n  2. If either the aspect member or the property member is not present in the third argument (query):
        * \n     2a.  If the second argument (errorCallback) is not an ECMAScript funtion, then terminate this algorithm skipping all steps below.
        * \n     2b.  Let exception be a new DOMException of type "TypeMismatchError", with message "Required aspect or property was not passed." (or similar).
        * \n     2c.  Queue a task to invoke the errorCallback with exception as the argument.
        * \n     2d.  Terminate this algorithm, skipping all steps below.
        * \n  3. Let aspect name be the result of trimming the value of the aspect member from the third argument (query).
        * \n  4. If aspect name does not match an enabled aspect:
        * \n     4a.  If the second argument (errorCallback) is not an ECMAScript function, then terminate this algorithm skipping all steps below.
        * \n     4b.  If aspect name is one found in all aspects, but was disabled by policy or via a feature string, then:
        * \n        4b1.   Let exception be a new DOMException of type "SecurityError", with message "Access to this component was blocked by policy." (or similar).
        * \n     4c.  If aspect name is not one found in the list of all aspects, then:
        * \n        4c1.   Let exception be a new DOMException of type "NotFoundError", with message "Aspect could not be found." (or similar).
        * \n     4d.  Queue a task to invoke the errorCallback with exception as the argument.
        * \n     4e.  Terminate this algorithm, skipping all steps below.
        * \n  5. Let prop name be the result of trimming the value of the property member from the third argument (query).
        * \n  6. If the component member is present in query, let component name be the result of trimming component member.
        * \n  7. If the component name is not component of the aspect aspect name (e.g., {aspect:"Battery", component: "screen1"}:
        * \n     7a.  If the second argument (errorCallback) is not an ECMAScript function, then terminate this algorithm skipping all steps below.
        * \n     7b.  Let exception be a new DOMException of type "InvalidAccessError", with message "Component is not an instance of aspect." (or similar).
        * \n     7c.  Queue a task to invoke the errorCallback with exception as the argument.
        * \n     7d.  Terminate this algorithm, skipping all steps below.
        * \n  8. If the component member is not present in query:
        * \n     8a.  If the aspect aspect name has an active component, then let component name be "_active". Otherwise, let component name be "_default".
        * \n  9. If the component component name does not have the property property name (e.g., {aspect:"Battery", component: "_active", "fooBar"):
        * \n     9a.  If the second argument (errorCallback) is not an ECMAScript function, then terminate this algorithm skipping all steps below.
        * \n     9b.  Let exception be a new DOMException of type "NotFoundError", with message "Property not found in component." (or similar).
        * \n     9c.  Queue a task to invoke the errorCallback with exception as the argument.
        * \n     9d.  Terminate this algorithm, skipping all steps below.
        * \n 10. Let task be a task that does the following:
        * \n    10a.  Let value be the value of property property name of the component component name.
        * \n    10b.  Invoke the successCallback with value as the argument.
        * \n 11. Let op be and object that implements the PendingOperation interface.
        * \n 12. Associate task with op, so that if op's cancel() method is invoked, it attempts to remove task for the callbacks task queue.
        * \n 13. Queue a task task.
        * \n 14. Return op.
        * 
        * Example
        * \code
//The "_default" component is implied.
var options = {
	aspect: "Battery",
	property: "batteryLevel"
};

deviceapis.devicestatus.getPropertyValue(
function batteryQuery(value) {
	console.log("Battery is at " + value + "%");
},
null, options);
        * \endcode
        * \param successCallback Function to call on successfully retrieving a property value
        * \param errorCallback Function to call if property value could not be retrieved
        * \param query Property to retrieve
        * \return PendingOperation enabling the requester to cancel this request.        
        */
    PendingOperation getPropertyValue(Function  successCallback,
                                      ErrorCB? errorCallback,
                                      PropQuery query);


       /**
        * \brief The watchPropertyChange() method allows the developer to watch for changes to the properties of components.
        * 
        * ACCEL-watch-acceleration: When the watchPropertyChange() method is invoked, the user agent MUST run the steps for watching property changes.
        *         
        * Steps for watching the acceleration
        * 
        * The steps for watching property changes is given by the following algorithm:
        * 
        * \n  1. Run the general invocation checks algorithm. If no exceptions were generated, continue.
        * \n  2. Let subscription id be a user-agent-defined (random or sequential) unique integer that will represent the looping action to be created by invoking this method.
        * \n  3. Add subscription id to the list of active watch operations.
        * \n  4. Return subscription id, and then continue running this algorithm asynchronously.
        * \n  5. Let interval be the value 0.
        * \n  6. If the fourth argument (options) is present:
        * \n     6a.  If the minChangePercent member is present, and it is a number greater than 0, then let percent interval be the value of minChangePercent.
        * \n     6b.  If the minNotificationInterval member is present, and it is a number, then let interval be the value of minNotificationInterval.
        * \n     6c.  If the maxNotificationInterval member is present, and it is a number, then let max interval be the value of minNotificationInterval.
        * \n  7. If interval is less than a user-agent-defined value for a the smallest ammount of time between intevals (i.e., to protect the component from being flooded with requests or because it would drain too much battery, etc.), set interval to that user-agent-defined value.
        * \n  8. If max interval is less than interval, discard max interval.
        * \n  9. Let old value be the value 0.
        * \n 10. Wait, at a minimum (optionally more time if needed), the amount of time indicated by the interval. If the max interval was not discarded, and the time waited exceeds the max interval, do this step again (i.e., wait).
        * \n 11. If the entry for subscription id has been cleared from the list of active watch operations, terminate this algorithm. If subscription id has not been cleared from the list of active watch operations, create a task to run the getPropertyValue() method using successCallback as the first argument, and, if present, errorCallback as the second argument, and query dictionary as the third argument. Discard the resulting PendingOperation object.
        * \n 12. TODO: Factor in the minChangePercent change value. Only queue the task when the change between the old value and new value is minChangePercent or greater.
        * \n 13. Queue the task task.
        * \n 14. Return to step labelled wait.
        * 
        * Example
        * \code
function propertyChange(value, ref) {
	console.log("New value for " + ref.property + " is " + value);
}

deviceapis.devicestatus.watchPropertyChange(propertyChange, null, {
	property: "batteryLevel",
	aspect: "Battery"
});

//The "_default" component is implied.
var options = {
	aspect: "Battery",
	property: "batteryLevel"
};

deviceapis.devicestatus.getPropertyValue(
function batteryQuery(value) {
	console.log("Battery is at " + value + "%");
},
null, options);
        * \endcode
        * \param successCallback Function to call on changing property value
        * \param errorCallback Function to call if an error occurs
        * \param query Property to watch
        * \param options Additonal options for property watch, such as the minimum range of change
        * \return Subscription ID
        */

    long watchPropertyChange(Function successCallback,
                             ErrorCB? errorCallback,
                             PropQuery query,
                             optional WatchOptions? options);
                             
       /**
        * \brief Unsubscribe from notifications for property changes set up by watchPropertyChange.
        * 
        * 
        * If a valid watchid argument is passed that corresponds to a subscription already in place, then the watch process MUST immediately terminate and no further callbacks MUST be invoked. If the watchid argument does not correspond to a valid subscription, the method should return without any further action.
        * Example
        * \code
           function propertyChange(value, ref) {
           	console.log("New value for " + ref.property + " is " + value);
           
           	if (id) {
           		deviceapis.devicestatus.clearPropertyChange(id);
           		console.log(id + " cleared");
           	}
           }
           
           var id = deviceapis.devicestatus.watchPropertyChange(
           propertyChange, null, {
           	property: "batteryLevel",
           	aspect: "Battery"
           });
        * \endcode
        * \param watchid Id of watch property change subscription
        */
    void clearPropertyChange(long watchid);
  };
  
       /**
        * \brief       The PropQuery provides a way to query an component about a property. 
        */
dictionary PropQuery {
       /**
        * \brief       The component member represents the component that is to be queried. If it is not present, the user agent will try to use either the active component or the default component for a given aspect (e.g., "screen1"). 
        */
     DOMString component;
       /**
        * \brief       The aspect member takes the identifier of an aspect (e.g., "Battery"). 
        */
     DOMString aspect;
       /**
        * \brief       The property member takes the name of a property of a component ("batteryBeingCharged"). 
        */
     DOMString property;
};  

        /**
        * \brief Possible values for switch
        */
        enum SwitchType {"ON", "OFF"};
        /**
        * \brief Possible values for network states
        */
        enum NetworkStates {"connected", "available", "forbidden"};

 
Deviceapis implements DeviceapisDeviceStatusManager;
