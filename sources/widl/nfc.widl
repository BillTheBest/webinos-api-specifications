/**
 * \brief Interface for NFC Tags reader/writer.
 *
 * API to read and write to NFC tags.
 * This specification provides a new DOM event ("nfctag") to discover when a nfc tag
 * enters the field of the device.
 *
 * \code
 * window.addEventListener("nfctag", nfcListener, true);
 *
 * function nfcListener(event)
 * {
 *   var techSelected = null;
 *   var techSupported = event.tag.techList;
 *   if(techSupported.length > 0) {
 *     for (var index=0; index &lt; techSupported.length; index++) {
 *       if(techSupported[index].type == techSupported[index].TECH_NDEF) {
 *         techSelected = techSupported[index];
 *       }
 *     }
 *   }
 *   if(techSelected) {
 *     var ndefMessage = techSelected.readCachedNdefMessage();
 *     for (var index=0; index &lt; ndefMessage.ndefRecords.length) {
 *       if(ndefMessage.ndefRecords[index].type = ndefMessage.NDEFRECTYPE_URI)
 *			alert("uri found: "+ndefMessage.ndefRecords[index].textPayload);
 *     }
 *   }
 * }
 * \endcode
 *
 * \def-api-feature http://webinos.org/api/nfc
 * Acccess to all the module. This feature provides access to the whole API.
 *
 * \def-api-feature http://webinos.org/api/nfc.read
 * Acccess to all the module except write operations.
 *
 * \author Hans Mirhaug &lt;hans@ambiesense.com&gt;
 * \author Stefano Vercelli &lt;stefano.vercelli@telecomitalia.it&gt;
 *
 * \version 0.3
 */

module nfc {

	/**
	 * \brief Array of NFCTagTechnology.
	 */
	typedef sequence<NFCTagTechnology>	NFCTagTechnologyArray;

	/**
	 * \brief Array of NdefRecord.
	 */
	typedef sequence<NdefRecord>	NdefRecordArray;

	/**
	 * \brief Array of 8-bit unsigned integer values.
	 */
	typedef sequence<unsigned short>	ByteArray;

	/**
	 * \brief Definition of pending op.
	 * 
	 */
	[NoInterfaceObject] interface PendingOperation {
		/**
		 * \brief Cancel the async op.
		 *
		 */
		boolean cancel();
	};

	
	/**
	 * \brief NFC tag event.
	 *
	 */
	[NoInterfaceObject] interface NFCTag : Event {

		/**
		 * \brief The identifier of the tag.
		 *
		 */
		readonly attribute ByteArray tagId;
		
		/**
		 * \brief The list of technologies supported by the tag.
		 *
		 */
		readonly attribute NFCTagTechnologyArray techList;
		
		/**
		 * \brief Method to set initial values of NFCTag event.  
		 *
		 * The initNFCTagEvent() method must initialize the event in a manner analogous to the initEvent() method in http://www.w3.org/TR/2010/WD-DOM-Level-3-Events-20100907/.
		 * The method can for example be used with document.createEvent() and EventTarget.dispatchEvent() to simulate a specific event.
		 * At the moment it should simulate a read only ndef Tag containing a ndefMessage that includes a single ndefRecord.
		 *   
		 * \param type Event type i.e. 'sensor'
		 * \param bubbles True if event bubbles
		 * \param cancelable True if event cancelable
		 * \param tagId id of the tag
		 * \param technologyType type of technology supported by the tag; at the moment it must be ndef.
		 * \param ndefType type of ndef supported (see constants defined in NFCTagTechnologyNdef)
		 * \param ndefRecType type of ndef record (see constants defined in NdefMessage)
		 * \param ndefRecordTextPayload textual payload of the ndef record
		 * \param ndefRecordBinaryPayload binary payload of the ndef record
		 */
		void initNFCTagEvent(in DOMString type,
		                     in boolean bubbles,
		                     in boolean cancelable,
		                     in ByteArray tagId,
							 in unsigned short technologyType,
							 in unsigned short ndefType,
							 in unsigned short ndefRecType,
							 in DOMString? ndefRecordTextPayload,
							 in optional ByteArray ndefRecordBinaryPayload
		                     );
								 
	};


	/**
	 * \brief NFC technology.
	 *
	 */
	[NoInterfaceObject] interface NFCTagTechnology {

		/**
		 * \brief Constant identifying a non supported technology.
		 *
		 */
		const unsigned short TECH_OTHERS = 0;
		
		/**
		 * \brief Constant identifying a NfcA technology.
		 *
		 */
		const unsigned short TECH_NFCA = 1;
		
		/**
		 * \brief Constant identifying a NfcB technology.
		 *
		 */
		const unsigned short TECH_NFCB = 2;
		
		/**
		 * \brief Constant identifying a NfcF technology.
		 *
		 */
		const unsigned short TECH_NFCF = 3;
		
		/**
		 * \brief Constant identifying a NfcV technology.
		 *
		 */
		const unsigned short TECH_NFCV = 4;
		
		/**
		 * \brief Constant identifying a IsoDep technology.
		 *
		 */
		const unsigned short TECH_ISODEP = 5;
		
		/**
		 * \brief Constant identifying a Ndef technology.
		 *
		 */
		const unsigned short TECH_NDEF = 6;
		
		/**
		 * \brief Type of technology.
		 *
		 */
		readonly attribute unsigned short type;
		
		/**
		 * \brief Attribute indicating if the tag is connected or not.
		 *
		 * TODO: check if it is needed.
		 *
		 */
		readonly attribute boolean isConnected;
		
		/**
		 * \brief Connects to the tag.
		 *
		 * TODO: check if it is needed.
		 *
		 */
		void connect();

		/**
		 * \brief Closes connection to the tag.
		 *
		 * TODO: check if it is needed.
		 *
		 */
		void close();
		
	};

	
	/**
	 * \brief Ndef technology.
	 *
	 * \code
	 * window.addEventListener("nfctag", nfcListener, true);
	 *
	 * function nfcListener(event)
	 * {
	 *   var techSelected = null;
	 *   var techSupported = event.tag.techList;
	 *   if(techSupported.length > 0) {
	 *     for (var index=0; index &lt; techSupported.length; index++) {
	 *       if(techSupported[index].type == techSupported[index].TECH_NDEF) {
	 *         techSelected = techSupported[index];
	 *       }
	 *     }
	 *   }
	 *   // write to the tag
	 *   if(techSelected) {
	 *     var newMsg = techSelected.createNdefMessage();
	 *     newMsg.addTextNdefRecord(newMsg.NDEFRECTYPE_URI, "http://webinos.org");
	 *     techSelected.writeNdefMessage(wSuccess, wError, newMsg);
	 *   }
	 * }
	 *
	 * function wSuccess()
	 * {
	 *   alert("write successfull");
	 * }
	 *
	 * function wError()
	 * {
	 *   alert("write error");
	 * }
	 *
	 * \endcode
	 *
	 */
	[NoInterfaceObject] interface NFCTagTechnologyNdef : NFCTagTechnology {
	
		/**
		 * \brief Constant identifying a non supported Ndef format.
		 *
		 */
		const unsigned short NDEFTYPE_OTHERS = 0;
		
		/**
		 * \brief Constant identifying a Nfc forum type 1 Ndef tag.
		 *
		 */
		const unsigned short NDEFTYPE_NFCFORUMTYPE1 = 1;
		
		/**
		 * \brief Constant identifying a Nfc forum type 2 Ndef tag.
		 *
		 */
		const unsigned short NDEFTYPE_NFCFORUMTYPE2 = 2;
		
		/**
		 * \brief Constant identifying a Nfc forum type 3 Ndef tag.
		 *
		 */
		const unsigned short NDEFTYPE_NFCFORUMTYPE3 = 3;
		
		/**
		 * \brief Constant identifying a Nfc forum type 4 Ndef tag.
		 *
		 */
		const unsigned short NDEFTYPE_NFCFORUMTYPE4 = 4;
		
		/**
		 * \brief Constant identifying a Mifare classic Ndef formatted tag.
		 *
		 */
		const unsigned short NDEFTYPE_MIFARECLASSIC = 5;
		
		/**
		 * \brief Attribute indicating the type of Ndef tag.
		 *
		 */
		readonly attribute unsigned short ndefType;
		
		/**
		 * \brief Attribute indicating if the tag is writable or not.
		 *
		 */
		readonly attribute boolean isWritable;
		
		/**
		 * \brief Attribute indicating the maximum size of Ndef messages.
		 *
		 */
		readonly attribute unsigned long maxNdefMessageSize;
		
		/**
		 * \brief This method makes a tag read-only.
		 *
	     * \param successCallback function to be invoked in case of success.
	     * \param errorCallback function to be invoked in case of failure.
		 * \return PendingOperation to cancel the asynchronous call 
		 */
		PendingOperation makeReadOnly(in SuccessCallback successCallback, in ErrorCallback errorCallback);
		
		/**
		 * \brief Retrieves the Ndef message received at discovery time.
		 *
		 * \return The Ndef message received at discovery time.
		 */
		NdefMessage readCachedNdefMessage();
		
		/**
		 * \brief This method reads a Ndef message.
		 *
	     * \param successCallback function to be invoked in case of success.
	     * \param errorCallback function to be invoked in case of failure.
		 * \return PendingOperation to cancel the asynchronous call 
		 */
		PendingOperation readNdefMessage(in NdefSuccessCallback successCallback, in ErrorCallback errorCallback);
		
		/**
		 * \brief Writes a Ndef message to the tag.
		 *
	     * \param successCallback function to be invoked in case of success.
	     * \param errorCallback function to be invoked in case of failure.
	     * \param message The message to be written.
		 * \return PendingOperation to cancel the asynchronous call 
		 */
		PendingOperation writeNdefMessage(in SuccessCallback successCallback, in ErrorCallback errorCallback, NdefMessage message);
		
		/**
		 * \brief Create a new Ndef message.
		 *
		 * \return The new Ndef message; it is empty, that is does not contain ndef records
		 */
		NdefMessage createNdefMessage();

	};
	

	/**
	 * \brief Ndef message.
	 *
	 */
	[NoInterfaceObject] interface NdefMessage {
	
		/**
		 * \brief Constant identifying an unknown Ndef record type.
		 *
		 */
		const unsigned short NDEFRECTYPE_UNKNOWN = 0;

		/**
		 * \brief Constant identifying a uri Ndef record type.
		 *
		 */
		const unsigned short NDEFRECTYPE_URI = 1;

		/**
		 * \brief Constant identifying a media Ndef record type.
		 *
		 */
		const unsigned short NDEFRECTYPE_MEDIA = 2;

		/**
		 * \brief Constant identifying an empty Ndef record type.
		 *
		 */
		const unsigned short NDEFRECTYPE_EMPTY = 3;

		/**
		 * \brief Constant identifying a RTD Ndef record type.
		 *
		 */
		const unsigned short NDEFRECTYPE_RTD = 4;

		/**
		 * \brief Constant identifying an external RTD Ndef record type.
		 *
		 */
		const unsigned short NDEFRECTYPE_EXTERNALRTD = 5;

		/**
		 * \brief List of Ndef records.
		 *
		 */
		readonly attribute NdefRecordArray ndefRecords;
		
		/**
		 * \brief Adds a text record to the Ndef message.
		 *
		 * TODO add exceptions
		 *
		 * \param type The type of the ndef record
		 * \param payload The text payload of the record
		 */
		void addTextNdefRecord(in unsigned short type, in optional DOMString payload);
		
		/**
		 * \brief Adds a binary record to the Ndef message.
		 *
		 * TODO add exceptions
		 *
		 * \param type The type of the ndef record
		 * \param payload The binary payload of the record
		 */
		void addBinaryNdefRecord(in unsigned short type, in ByteArray payload);
		
	};
	
	
	/**
	 * \brief Ndef record.
	 *
	 * Chunk of records are assembled by the underlying implementation and returned as
	 * a single Ndef record.
	 *
	 */
	[NoInterfaceObject] interface NdefRecord {
	
		/**
		 * \brief The type of the record.
		 *
		 */
		readonly attribute unsigned short type;
		
		/**
		 * \brief The textual payload of the record.
		 *
		 */
		readonly attribute DOMString textPayload;
		
		/**
		 * \brief The binary payload of the record.
		 *
		 */
		readonly attribute ByteArray binaryPayload;
		
	};
	
	
	/**
	 * \brief Callback to be invoked when reading a Ndef message.
	 *
	 */
	[Callback=FunctionOnly, NoInterfaceObject] interface NdefSuccessCallback {
		void onSuccess(in NdefMessage obj);
	};
	
};

