/**<p> Near Field Communication (NFC) support.</p> 
 * \name NFC API
 *
 * Near Field Communication (NFC) is an international standard (ISO/IEC 
 * 18092) that specifies an interface and protocol for simple wireless 
 * interconnection of closely coupled devices operating at 13.56 MHz. 
 * (http://www.nfc-forum.org/specs/spec_list/).
 * There are three groups of application scenarios for NFC: The first one 
 * is to hold a device close to a wireless tag to exchange some digital 
 * information or data. The second is to hold two devices close to each 
 * other in order to exchange some information or data between them. The 
 * third one is to make payments by holding mobile phones close to point of 
 * sales terminals instead of swiping smart cards.
 * 
 * Near Field Communication is a kind of radio-frequency identification 
 * (RFID) technology that uses short-hold wireless communication to 
 * transfer messages between wireless NFC devices and NFC tags. The 
 * wireless tags are physically attached onto/ mounted nearby a physical 
 * object.
 * 
 * The most common use case is for an NFC device to read the identifier 
 * and/or the contents of an NFC tag. Another quite common use case is for 
 * an NFC device to write content to an NFC tag, if the NFC tag allows 
 * this. The webinos NFC module supports both. There is also a third use 
 * case where NFC devices pretend to be contactless smart cards e.g. for 
 * payment or ticketing purposes. In general, our objective is with the 
 * webinos NFC module is to enable free competition for NFC applications. 
 * This means that the goal is to allow any application developers to fully 
 * operate on any of these modes.
 * 
 * The purpose of an NFC tag is to provide a small amount of digital data 
 * about the physical object that it is associated with - or to help 
 * perform a task for the user. One can use either the tag identifier, or 
 * some data stored on the tag, to achieve this.
 * 
 * An NFC tag can be viewed as a wireless bar code. It can be read by NFC 
 * devices within a range of up to 10 centimetres. The amount of power and 
 * resources needed by the NFC device to read and write to an NFC tag is 
 * very low.
 * 
 * - NFC APPLICATIONS AND USE CASES
 * 
 * NFC technology is increasingly taking part in every day activities. NFC 
 * enables digital data to be associated with real world objects. NFC tags 
 * are more advanced than printed bar codes, because one can store a few 
 * kilobytes of data on each NFC tag in addition to using its identifier.
 * 
 * NFC is a wireless standard where messages must be exchanged and 
 * communicated in a standardised way. This makes NFC very suitable for a 
 * wide range of ubiquitous applications. Example applications are within 
 * logistics, health care, social media, infotainment, gaming, mobile 
 * payments, access to places, system access, inventory control, exchange 
 * of business cards, email addresses, web links, images, and so on.
 * 
 * - NFC CORE CONCEPTS
 * 
 * The core concepts of the NFC standard are:
 * 
 * * The NFC devices and NFC tags
 * * The NFC Data Exchange Format
 * 
 * NFC devices are are typically mobile phones or computers with some NFC 
 * hardware and a driver installed. Such devices are typically active and 
 * try to detect tags, or other devices, nearby. The devices and tags can 
 * be provided with identifiers, and these can be both fixed or dynamic 
 * depending on the application.
 * 
 * NFC tags can be worn by people or attached to objects in the 
 * environment. It enables identification and exchange of a small amount of 
 * data in the form of standardised messages that can contain up to several 
 * data records each. Each data record contains a header identifying the 
 * data followed by the actual data itself. It is completely up to 
 * application developers to identify the data, to understand it, and to 
 * use the data. Please note that sometimes the term payload is also being 
 * used in NFC. Payload in an NFC context simply refers to the raw data or 
 * information being stored.
 * 
 * - THE NFC DATA EXCHANGE FORMAT
 * 
 * The NFC Forum has specified the NFC Data Exchange Format (NDEF) to 
 * enable interoperability when exchanging data between NFC devices and NFC 
 * tags. NDEF is a standard that specifies the NDEF data structure format 
 * along with rules on how to compose an NDEF message as a complete 
 * collection of NDEF records. An NDEF message is a lightweight, binary 
 * message format.
 * 
 * It defines how to package application data as NDEF records. NDEF only 
 * specified the data structure format to exchange application specific 
 * data in an interoperable way. It does not define any record types in 
 * detail. Providing the record header and the actual record data is 
 * completely up to the application developer to do.
 * 
 * NDEF is a compact and lightweight binary format. It can contain any data 
 * such as web links, business cards, tiny applications, images, and so on. 
 * It is up the application developers to define and fill it with literally 
 * any data suitable or needed for the application. It is the capabilities 
 * of the NFC target that matters. Most NFC tags have generally a few 
 * kilobytes of available memory to store the data (payload). NFC devices 
 * typically have much more memory available. There are currently four 
 * types of NFC tags defined in the standard: type1, type 2, type 3, and 
 * type 4. The type vary because of computing capabilities and low level 
 * commands, but all NFC targets have to support the exchange of NDEF 
 * messages and records.
 * 
 * The advantage of NDEF is that it abstracts away from the specific NFC 
 * tags/ targets. An NDEF message consists of a set of NDEF records. Each 
 * record must carry data/ payload. The type of data can for instance be 
 * web links, MIME media types, or pre-defined NFC data types.
 * An NDEF record consists of two parts: 1) the header part, and 2) the 
 * data (payload) part. The compact header part specifies the: i) type of 
 * data, ii) the length of the data in terms of octets, and iii) an 
 * optional data identifier. The optional data identifier could for 
 * instance be used by applications to nest data and records, or for other 
 * purposes such as signing. i) and ii) are mandatory to specify in the 
 * header of a record. Also, the data (payload) part needs to be provided 
 * to the record. The approach to specifying headers allows for compact the 
 * identification of standardised data formats across NFC applications. It 
 * also allows for the identification of new and custom data formats for 
 * any future NFC application.
 * 
 * The NDEF message format can accommodate literally any information or 
 * data of known and initially unknown sizes. It allows an arbitrary set of 
 * information and data to be grouped together into a single message. It 
 * also allows for the compact encapsulation of well-known data such as web 
 * links. An NDEF message is not a general message description or document 
 * format like MIME media types, HTML, XML and so on. Rather, the purpose 
 * is to enable applications to take advantage of such descriptions and 
 * formats by encapsulating any of these as NDEF messages and records.
 * 
 * The data (payload) length is an unsigned integer indicating the number 
 * of octets in the payload. A compact, short-record layout is provided for 
 * very small payloads. The optional payload identifier enables association 
 * of multiple data (payloads) and cross-referencing between them. NDEF 
 * payloads may include nested NDEF messages or chains
 * of linked chunks of unknown length at the time the data is generated.
 * 
 * - BRIEFLY HOW NFC RADIOS AND MODULES WORK
 * 
 * NFC tags differ from many other RFID tags mainly because of the signal 
 * range of the NFC transceivers. Some RFID tags can be read from 100 
 * meters, which is the case when you drive a car through a toll ring with 
 * an RFID tag. Such long range wireless tag needs an embedded battery to 
 * be able to broadcast the identifier/ data back to the reader. However, 
 * because the signal reach of NFC tags and devices is only a few 
 * centimetres, the actual NFC tags require no battery. Instead, the active 
 * NFC device activates the passive NFC tag with an electro-magnetic field. 
 * This field is sufficient to power the NFC chip and drive the data exchange.
 * 
 * - PLANNED OPERATING MODES FOR THE WEBINOS NFC
 * 
 * NFC devices can run in either reader-writer mode, peer-to-peer mode, or 
 * card emulation mode. These three modes are based on the ISO/IEC 18092 
 * NFC IP-1 and ISO/IEC 14443 contactless smart card standards. Webinos aim 
 * to provide all three modes:
 * 
 * 1. NFC reader/writer mode - the NFC device can read and write data to 
 * NFC tags. This is the original intention of the NFC technologies. We 
 * foresee that most NFC applications will be using this mode in the 
 * beginning. One use case is to hold a mobile towards a smart poster to 
 * obtain information about a concert.
 * 
 * 2. NFC peer to peer mode - two NFC devices exchange data with each other 
 * when held close. The devices can connect and share any data/ files 
 * through the NFC Logical Link Control Protocol (LLCP). This capability 
 * was added to the NFC standard because of the introduction of NFC 
 * adapters to mobile phones.
 * 
 * 3. NFC card emulation mode - an NFC device appears to another NFC device 
 * as a contactless smart card. It makes the NFC device appear as a 
 * contactless smart card for payment/ ticketing to other NFC devices. A 
 * contactless card an NFC tag with a tiny, secure application embedded on 
 * it. Therefore, one needs to emulate cards through the execution of tiny, 
 * secure payment applications towards the NFC module.
 * 
 * The implementation priority for the webinos NFC module is in the order 
 * if the above three modes: We first will provide the NFC reader/writer 
 * mode, then we will deliver the NFC peer to peer mode. Finally, we aim to 
 * get the NFC card emulation mode implemented, however, at the moment this 
 * latter mode has a lower priority in webinos.
 * 
 * This specification provides a new DOM event ("nfctag") to discover when a nfc tag
 * enters the field of the device.
 *
 * \code
 * window.addEventListener("nfctag", nfcListener, true);
 *
 * function nfcListener(event)
 * {
 *   var techSelected = null;
 *   var techSupported = event.tag.techList;
 *   if(techSupported.length > 0) {
 *     for (var index=0; index &lt; techSupported.length; index++) {
 *       if(techSupported[index].type == techSupported[index].TECH_NDEF) {
 *         techSelected = techSupported[index];
 *       }
 *     }
 *   }
 *   if(techSelected) {
 *     var ndefMessage = techSelected.readCachedNdefMessage();
 *     for (var index=0; index &lt; ndefMessage.ndefRecords.length) {
 *       if(ndefMessage.ndefRecords[index].type = ndefMessage.NDEFRECTYPE_URI)
 *                      alert("uri found: "+ndefMessage.ndefRecords[index].textPayload);
 *     }
 *   }
 * }
 * \endcode
 *
 * \def-api-feature http://webinos.org/api/nfc
 * Acccess to all the module. This feature provides access to the whole API.
 *
 * \def-api-feature http://webinos.org/api/nfc.read
 * Acccess to all the module except write operations.
 *
 * \author Hans Myrhaug (AmbieSense Ltd.) &lt;hans@ambiesense.com&gt;
 * \author Stefano Vercelli (Telecom Italia) &lt;stefano.vercelli@telecomitalia.it&gt;
 * \author Updated to new WIDL format by Christian Fuhrhop &lt;christian.fuhrhop@fokus.fraunhofer.de&gt;
 *
 * \version 0.5
 */


        /**
         * \brief Array of NFCTagTechnology.
         */
        typedef NFCTagTechnology[]      NFCTagTechnologyArray;

        /**
         * \brief Array of NdefRecord.
         */
        typedef NdefRecord[]    NdefRecordArray;

        /**
         * \brief Array of 8-bit unsigned integer values.
         */
        typedef octet[] ByteArray;

        /**
         * \brief Definition of pending op.
         * 
         */
        [NoInterfaceObject] interface PendingOperation {
                /**
                 * \brief Cancel the async op.
                 *
                 */
                boolean cancel();
        };

        
        /**
         * \brief NFC tag event.
         *
         */
        interface NFCTag : Event {

                /**
                 * \brief The identifier of the tag.
                 *
                 */
                readonly attribute ByteArray tagId;
                
                /**
                 * \brief The list of technologies supported by the tag.
                 *
                 */
                readonly attribute NFCTagTechnologyArray techList;
                
                /**
                 * \brief Method to set initial values of NFCTag event.  
                 *
                 * The initNFCTagEvent() method must initialize the event in a manner analogous to the initEvent() method in http://www.w3.org/TR/2010/WD-DOM-Level-3-Events-20100907/.
                 * The method can for example be used with document.createEvent() and EventTarget.dispatchEvent() to simulate a specific event.
                 * At the moment it should simulate a read only ndef Tag containing a ndefMessage that includes a single ndefRecord.
                 *   
                 * \param type Event type i.e. 'sensor'
                 * \param bubbles True if event bubbles
                 * \param cancelable True if event cancelable
                 * \param tagId id of the tag
                 * \param technologyType type of technology supported by the tag; at the moment it must be ndef.
                 * \param ndefType type of ndef supported (see constants defined in NFCTagTechnologyNdef)
                 * \param ndefRecType type of ndef record (see constants defined in NdefMessage)
                 * \param ndefRecordTextPayload textual payload of the ndef record
                 * \param ndefRecordBinaryPayload binary payload of the ndef record
                 */
                void initNFCTagEvent(DOMString type,
                                     boolean bubbles,
                                     boolean cancelable,
                                     ByteArray tagId,
                                     unsigned short technologyType,
                                     unsigned short ndefType,
                                     unsigned short ndefRecType,
                                     DOMString? ndefRecordTextPayload,
                                     optional ByteArray ndefRecordBinaryPayload
                                     );
                                                                 
        };


        /**
         * \brief NFC technology.
         *
         */
        [NoInterfaceObject] interface NFCTagTechnology {

                /**
                 * \brief Constant identifying a non supported technology.
                 *
                 */
                const unsigned short TECH_OTHERS = 0;
                
                /**
                 * \brief Constant identifying a NfcA technology.
                 *
                 */
                const unsigned short TECH_NFCA = 1;
                
                /**
                 * \brief Constant identifying a NfcB technology.
                 *
                 */
                const unsigned short TECH_NFCB = 2;
                
                /**
                 * \brief Constant identifying a NfcF technology.
                 *
                 */
                const unsigned short TECH_NFCF = 3;
                
                /**
                 * \brief Constant identifying a NfcV technology.
                 *
                 */
                const unsigned short TECH_NFCV = 4;
                
                /**
                 * \brief Constant identifying a IsoDep technology.
                 *
                 */
                const unsigned short TECH_ISODEP = 5;
                
                /**
                 * \brief Constant identifying a Ndef technology.
                 *
                 */
                const unsigned short TECH_NDEF = 6;
                
                /**
                 * \brief Type of technology.
                 *
                 */
                readonly attribute unsigned short type;
                
                /**
                 * \brief Attribute indicating if the tag is connected or not.
                 *
                 * TODO: check if it is needed.
                 *
                 */
                readonly attribute boolean isConnected;
                
                /**
                 * \brief Connects to the tag.
                 *
                 * TODO: check if it is needed.
                 *
                 */
                void connect();

                /**
                 * \brief Closes connection to the tag.
                 *
                 * TODO: check if it is needed.
                 *
                 */
                void close();
                
        };

        
        /**
         * \brief Ndef technology.
         *
         * \code
         * window.addEventListener("nfctag", nfcListener, true);
         *
         * function nfcListener(event)
         * {
         *   var techSelected = null;
         *   var techSupported = event.tag.techList;
         *   if(techSupported.length > 0) {
         *     for (var index=0; index &lt; techSupported.length; index++) {
         *       if(techSupported[index].type == techSupported[index].TECH_NDEF) {
         *         techSelected = techSupported[index];
         *       }
         *     }
         *   }
         *   // write to the tag
         *   if(techSelected) {
         *     var newMsg = techSelected.createNdefMessage();
         *     newMsg.addTextNdefRecord(newMsg.NDEFRECTYPE_URI, "http://webinos.org");
         *     techSelected.writeNdefMessage(wSuccess, wError, newMsg);
         *   }
         * }
         *
         * function wSuccess()
         * {
         *   alert("write successfull");
         * }
         *
         * function wError()
         * {
         *   alert("write error");
         * }
         *
         * \endcode
         *
         */
        [NoInterfaceObject] interface NFCTagTechnologyNdef : NFCTagTechnology {
        
                /**
                 * \brief Constant identifying a non supported Ndef format.
                 *
                 */
                const unsigned short NDEFTYPE_OTHERS = 0;
                
                /**
                 * \brief Constant identifying a Nfc forum type 1 Ndef tag.
                 *
                 */
                const unsigned short NDEFTYPE_NFCFORUMTYPE1 = 1;
                
                /**
                 * \brief Constant identifying a Nfc forum type 2 Ndef tag.
                 *
                 */
                const unsigned short NDEFTYPE_NFCFORUMTYPE2 = 2;
                
                /**
                 * \brief Constant identifying a Nfc forum type 3 Ndef tag.
                 *
                 */
                const unsigned short NDEFTYPE_NFCFORUMTYPE3 = 3;
                
                /**
                 * \brief Constant identifying a Nfc forum type 4 Ndef tag.
                 *
                 */
                const unsigned short NDEFTYPE_NFCFORUMTYPE4 = 4;
                
                /**
                 * \brief Constant identifying a Mifare classic Ndef formatted tag.
                 *
                 */
                const unsigned short NDEFTYPE_MIFARECLASSIC = 5;
                
                /**
                 * \brief Attribute indicating the type of Ndef tag.
                 *
                 */
                readonly attribute unsigned short ndefType;
                
                /**
                 * \brief Attribute indicating if the tag is writable or not.
                 *
                 */
                readonly attribute boolean isWritable;
                
                /**
                 * \brief Attribute indicating the maximum size of Ndef messages.
                 *
                 */
                readonly attribute unsigned long maxNdefMessageSize;
                
                /**
                 * \brief This method makes a tag read-only.
                 *
                 * When the operation is fully completed the onsuccess method of the successCallback is called.
                 * Otherwise, the errorCallback will be invoked with an appropriate error code amongst the following:
                 * <ul>
                 * <li>
                 *  IO_ERR: if the write operation fails.
                 * <ul>
                 *
                 * Throws NfcException with error code INVALID_ARGUMENT_ERR if parameters are of the wrong type
                 *
             * \param successCallback function to be invoked in case of success.
             * \param errorCallback function to be invoked in case of failure.
                 * \return PendingOperation to cancel the asynchronous call 
                 */
                PendingOperation makeReadOnly(SuccessCallback successCallback, optional ErrorCallback? errorCallback);
                
                /**
                 * \brief Retrieves the Ndef message received at discovery time.
                 *
                 * \return The Ndef message received at discovery time.
                 */
                NdefMessage readCachedNdefMessage();
                
                /**
                 * \brief This method reads a Ndef message.
                 *
                 * When the operation is fully completed the onsuccess method of the successCallback is called.
                 * Otherwise, the errorCallback will be invoked with an appropriate error code amongst the following:
                 * <ul>
                 * <li>
                 *  IO_ERR: if the read operation fails.
                 * <ul>
                 *
                 * Throws NfcException with error code INVALID_ARGUMENT_ERR if parameters are of the wrong type
                 *
             * \param successCallback function to be invoked in case of success.
             * \param errorCallback function to be invoked in case of failure.
                 * \return PendingOperation to cancel the asynchronous call 
                 */
                PendingOperation readNdefMessage(NdefSuccessCallback successCallback, optional ErrorCallback? errorCallback);
                
                /**
                 * \brief Writes a Ndef message to the tag.
                 *
                 * When the operation is fully completed the onsuccess method of the successCallback is called.
                 * Otherwise, the errorCallback will be invoked with an appropriate error code amongst the following:
                 * <ul>
                 * <li>
                 *  IO_ERR: if the write operation fails.
                 * <ul>
                 *
                 * Throws NfcException with error code INVALID_ARGUMENT_ERR if parameters are of the wrong type
                 *
             * \param successCallback function to be invoked in case of success.
             * \param errorCallback function to be invoked in case of failure.
             * \param message The message to be written.
                 * \return PendingOperation to cancel the asynchronous call 
                 */
                PendingOperation writeNdefMessage(SuccessCallback successCallback, ErrorCallback? errorCallback, NdefMessage message);                        
                
                /**
                 * \brief Create a new Ndef message.
                 *
                 * \return The new Ndef message; it is empty, that is does not contain ndef records.
                 */
                NdefMessage createNdefMessage();

        };
        

        /**
         * \brief Ndef message.
         *
         */
        [NoInterfaceObject] interface NdefMessage {
        
                /**
                 * \brief Constant identifying an unknown Ndef record type.
                 *
                 */
                const unsigned short NDEFRECTYPE_UNKNOWN = 0;

                /**
                 * \brief Constant identifying a uri Ndef record type.
                 *
                 */
                const unsigned short NDEFRECTYPE_URI = 1;

                /**
                 * \brief Constant identifying a media Ndef record type.
                 *
                 */
                const unsigned short NDEFRECTYPE_MEDIA = 2;

                /**
                 * \brief Constant identifying an empty Ndef record type.
                 *
                 */
                const unsigned short NDEFRECTYPE_EMPTY = 3;

                /**
                 * \brief Constant identifying a RTD Ndef record type.
                 *
                 */
                const unsigned short NDEFRECTYPE_RTD = 4;

                /**
                 * \brief Constant identifying an external RTD Ndef record type.
                 *
                 */
                const unsigned short NDEFRECTYPE_EXTERNALRTD = 5;

                /**
                 * \brief List of Ndef records.
                 *
                 */
                readonly attribute NdefRecordArray ndefRecords;
                
                /**
                 * \brief Adds a text record to the Ndef message.
                 *
                 * TODO add exceptions
                 *
                 * Throws NfcException with error code INVALID_ARGUMENT_ERR if parameters are of the wrong type
                 *
                 * \param type The type of the ndef record
                 * \param payload The text payload of the record
                 * \throw NfcException with error code INVALID_ARGUMENT_ERR if parameters are of the wrong type
                 */
                void addTextNdefRecord(unsigned short type, optional DOMString payload);
                
                /**
                 * \brief Adds a binary record to the Ndef message.
                 *
                 * TODO add exceptions
                 *
                 * Throws NfcException with error code INVALID_ARGUMENT_ERR if parameters are of the wrong type
                 *
                 * \param type The type of the ndef record
                 * \param payload The binary payload of the record
                 * \throw NfcException with error code INVALID_ARGUMENT_ERR if parameters are of the wrong type
                 */
                void addBinaryNdefRecord(unsigned short type, ByteArray payload);
                
        };
        
        
        /**
         * \brief Ndef record.
         *
         * Chunk of records are assembled by the underlying implementation and returned as
         * a single Ndef record.
         *
         */
        [NoInterfaceObject] interface NdefRecord {
        
                /**
                 * \brief The type of the record.
                 *
                 */
                readonly attribute unsigned short type;
                
                /**
                 * \brief The textual payload of the record.
                 *
                 */
                readonly attribute DOMString textPayload;
                
                /**
                 * \brief The binary payload of the record.
                 *
                 */
                readonly attribute ByteArray binaryPayload;
                
        };
        
        
        /**
         * \brief Interface for reporting Nfc specific errors.
         *
         */
        [NoInterfaceObject] interface NfcError {
            
                /**
                 * \brief Code assigned when an error has occurred in Nfc API processing.
                 *
                 */
                readonly attribute unsigned short code;

                /**
                 * \brief Human readable message assigned when an error has occurred in Nfc API processing.
                 *
                 */
                readonly attribute DOMString message;

                /**
                 * \brief Unknown error.
                 *
                 */
                const unsigned short UNKNOWN_ERR = 0;

                /**
                 * \brief I/O error.
                 *
                 */
                const unsigned short IO_ERR = 1;
                
        };


        /*
         * \brief The NfcException
         *
         */
        exception NfcException {

                /**
                 * \brief Unknown error.
                 *
                 */
                const unsigned short UNKNOWN_ERR = 0;

                /**
                 * \brief An invalid parameter was provided when the requested method was invoked.
                 *
                 */
                const unsigned short INVALID_ARGUMENT_ERR       = 1;

                /**
             * \brief Error code.
                 * 
                 */     
                unsigned short code;

                /**
             * \brief Error message.
                 * 
                 */     
                DOMString message;

        };
        
        
        /**
         * \brief Callback to be invoked in case of success.
         *
         */
        [Callback=FunctionOnly, NoInterfaceObject] interface SuccessCallback {
                void onsuccess();
        };

        /**
         * \brief Callback to be invoked when an error occurs.
         *
         */
        [Callback=FunctionOnly, NoInterfaceObject] interface ErrorCallback {
                void onError(NfcError error);
        };

        /**
         * \brief Callback to be invoked when reading a Ndef message.
         *
         */
        [Callback=FunctionOnly, NoInterfaceObject] interface NdefSuccessCallback {
                void onSuccess(NdefMessage obj);
        };
        

