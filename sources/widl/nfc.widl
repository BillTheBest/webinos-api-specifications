/**
 * \brief Interface for NFC Tags reader/writer.
 *
 * API to read and write to NFC tags.
 * This specification provides a new DOM event ("nfctag") to discover when a nfc tag
 * enters the field of the device.
 *
 * \code
 * window.addEventListener("nfctag", nfcListener, true);
 *
 * function nfcListener(event)
 * {
 *   var techSelected = null;
 *   var techSupported = event.tag.techList;
 *   if(techSupported.length > 0) {
 *     for (var index=0; index &lt; techSupported.length; index++) {
 *       if(techSupported[index].type == techSupported[index].TECH_NDEF) {
 *         techSelected = techSupported[index];
 *       }
 *     }
 *   }
 *   if(techSelected) {
 *     var ndefMessage = techSelected.readCachedNdefMessage();
 *     for (var index=0; index &lt; ndefMessage.ndefRecords.length) {
 *       if(ndefMessage.ndefRecords[index].type = ndefMessage.NDEFRECTYPE_URI)
 *			alert("uri found: "+ndefMessage.ndefRecords[index].textPayload);
 *     }
 *   }
 * }
 * \endcode
 *
 * \def-api-feature http://webinos.org/api/nfc
 * Acccess to all the module. This feature provides access to the whole API.
 *
 * \def-api-feature http://webinos.org/api/nfc.read
 * Acccess to all the module except write operations.
 *
 * \author Hans Mirhaug &lt;hans@ambiesense.com&gt;
 * \author Stefano Vercelli &lt;stefano.vercelli@telecomitalia.it&gt;
 *
 * \version 0.2 
 */

module nfc {

	/**
	 * \brief Array of NFCTagTechnology.
	 */
	typedef sequence<NFCTagTechnology>	NFCTagTechnologyArray;

	/**
	 * \brief Array of NdefRecord.
	 */
	typedef sequence<NdefRecord>	NdefRecordArray;

	/**
	 * \brief Array of 8-bit unsigned integer values.
	 */
	typedef sequence<octet> ByteArray;

	/**
	 * \brief Definition of pending op.
	 * 
	 */
	[NoInterfaceObject] interface PendingOperation {
		/**
		 * \brief Cancel the async op.
		 *
		 */
		boolean cancel();
	};

	
	/**
	 * \brief NFC tag event.
	 *
	 */
	[NoInterfaceObject] interface NFCTag : Event {

		/**
		 * \brief The identifier of the tag.
		 *
		 */
		readonly attribute ByteArray tagId;
		
		/**
		 * \brief The list of technologies supported by the tag.
		 *
		 */
		readonly attribute NFCTagTechnologyArray techList;
		
	};


	/**
	 * \brief NFC technology.
	 *
	 */
	[NoInterfaceObject] interface NFCTagTechnology {

		/**
		 * \brief Constant identifying a non supported technology.
		 *
		 */
		const unsigned short TECH_OTHERS = 0;
		
		/**
		 * \brief Constant identifying a NfcA technology.
		 *
		 */
		const unsigned short TECH_NFCA = 1;
		
		/**
		 * \brief Constant identifying a NfcB technology.
		 *
		 */
		const unsigned short TECH_NFCB = 2;
		
		/**
		 * \brief Constant identifying a NfcF technology.
		 *
		 */
		const unsigned short TECH_NFCF = 3;
		
		/**
		 * \brief Constant identifying a NfcV technology.
		 *
		 */
		const unsigned short TECH_NFCV = 4;
		
		/**
		 * \brief Constant identifying a IsoDep technology.
		 *
		 */
		const unsigned short TECH_ISODEP = 5;
		
		/**
		 * \brief Constant identifying a Ndef technology.
		 *
		 */
		const unsigned short TECH_NDEF = 6;
		
		/**
		 * \brief Type of technology.
		 *
		 */
		readonly attribute unsigned short type;
		
		/**
		 * \brief Attribute indicating if the tag is connected or not.
		 *
		 */
		readonly attribute boolean isConnected;
		
		/**
		 * \brief Connects to the tag.
		 *
		 */
		void connect();

		/**
		 * \brief Closes connection to the tag.
		 *
		 */
		void close();
		
	};

	
	/**
	 * \brief Ndef technology.
	 *
	 * \code
	 * window.addEventListener("nfctag", nfcListener, true);
	 *
	 * function nfcListener(event)
	 * {
	 *   var techSelected = null;
	 *   var techSupported = event.tag.techList;
	 *   if(techSupported.length > 0) {
	 *     for (var index=0; index &lt; techSupported.length; index++) {
	 *       if(techSupported[index].type == techSupported[index].TECH_NDEF) {
	 *         techSelected = techSupported[index];
	 *       }
	 *     }
	 *   }
	 *   // write to the tag
	 *   if(techSelected) {
	 *     var newMsg = techSelected.createNdefMessage();
	 *     newMsg.addTextNdefRecord(newMsg.NDEFRECTYPE_URI, "http://webinos.org");
	 *     techSelected.writeNdefMessage(wSuccess, wError, newMsg);
	 *   }
	 * }
	 *
	 * function wSuccess()
	 * {
	 *   alert("write successfull");
	 * }
	 *
	 * function wError()
	 * {
	 *   alert("write error");
	 * }
	 *
	 * \endcode
	 *
	 */
	[NoInterfaceObject] interface NFCTagTechnologyNdef : NFCTagTechnology {
	
		/**
		 * \brief Constant identifying a non supported Ndef format.
		 *
		 */
		const unsigned short NDEFTYPE_OTHERS = 0;
		
		/**
		 * \brief Constant identifying a Nfc forum type 1 Ndef tag.
		 *
		 */
		const unsigned short NDEFTYPE_NFCFORUMTYPE1 = 1;
		
		/**
		 * \brief Constant identifying a Nfc forum type 2 Ndef tag.
		 *
		 */
		const unsigned short NDEFTYPE_NFCFORUMTYPE2 = 2;
		
		/**
		 * \brief Constant identifying a Nfc forum type 3 Ndef tag.
		 *
		 */
		const unsigned short NDEFTYPE_NFCFORUMTYPE3 = 3;
		
		/**
		 * \brief Constant identifying a Nfc forum type 4 Ndef tag.
		 *
		 */
		const unsigned short NDEFTYPE_NFCFORUMTYPE4 = 4;
		
		/**
		 * \brief Constant identifying a Mifare classic Ndef formatted tag.
		 *
		 */
		const unsigned short NDEFTYPE_MIFARECLASSIC = 5;
		
		/**
		 * \brief Attribute indicating the type of Ndef tag.
		 *
		 */
		readonly attribute unsigned short ndefType;
		
		/**
		 * \brief Attribute indicating if the tag is writable or not.
		 *
		 */
		readonly attribute boolean isWritable;
		
		/**
		 * \brief Attribute indicating the maximum size of Ndef messages.
		 *
		 */
		readonly attribute unsigned long maxNdefMessageSize;
		
		/**
		 * \brief This method makes a tag read-only.
		 *
	     * \param successCallback function to be invoked in case of success.
	     * \param errorCallback function to be invoked in case of failure.
		 * \return 
		 */
		PendingOperation makeReadOnly(in SuccessCallback successCallback, in ErrorCallback errorCallback);
		
		/**
		 * \brief Retrieves the Ndef message received at discovery time.
		 *
		 * \return The Ndef message received at discovery time.
		 */
		NdefMessage readCachedNdefMessage();
		
		/**
		 * \brief This method reads a Ndef message.
		 *
	     * \param successCallback function to be invoked in case of success.
	     * \param errorCallback function to be invoked in case of failure.
		 * \return 
		 */
		PendingOperation readNdefMessage(in NdefSuccessCallback successCallback, in ErrorCallback errorCallback);
		
		/**
		 * \brief Writes a Ndef message to the tag.
		 *
	     * \param successCallback function to be invoked in case of success.
	     * \param errorCallback function to be invoked in case of failure.
	     * \param message The message to be written.
		 * \return 
		 */
		PendingOperation writeNdefMessage(in SuccessCallback successCallback, in ErrorCallback errorCallback, NdefMessage message);
		
		/**
		 * \brief Create a new Ndef message.
		 *
		 * \return The new Ndef message
		 */
		NdefMessage createNdefMessage();

	};
	

	/**
	 * \brief Ndef message.
	 *
	 */
	[NoInterfaceObject] interface NdefMessage {
	
		/**
		 * \brief Constant identifying an unknown Ndef record type.
		 *
		 */
		const unsigned short NDEFRECTYPE_UNKNOWN = 0;

		/**
		 * \brief Constant identifying a uri Ndef record type.
		 *
		 */
		const unsigned short NDEFRECTYPE_URI = 1;

		/**
		 * \brief Constant identifying a media Ndef record type.
		 *
		 */
		const unsigned short NDEFRECTYPE_MEDIA = 2;

		/**
		 * \brief Constant identifying an empty Ndef record type.
		 *
		 */
		const unsigned short NDEFRECTYPE_EMPTY = 3;

		/**
		 * \brief Constant identifying a RTD Ndef record type.
		 *
		 */
		const unsigned short NDEFRECTYPE_RTD = 4;

		/**
		 * \brief Constant identifying an external RTD Ndef record type.
		 *
		 */
		const unsigned short NDEFRECTYPE_EXTERNALRTD = 5;

		/**
		 * \brief List of Ndef records.
		 *
		 */
		readonly attribute NdefRecordArray ndefRecords;
		
		/**
		 * \brief Adds a text record to the Ndef message.
		 *
		 */
		void addTextNdefRecord(in unsigned short type, in DOMString payload);
		
		/**
		 * \brief Adds a binary record to the Ndef message.
		 *
		 */
		void addBinaryNdefRecord(in unsigned short type, in ByteArray payload);
		
	};
	
	
	/**
	 * \brief Ndef record.
	 *
	 * Chunk of records are assembled by the underlying implementation and returned as
	 * a single Ndef record.
	 *
	 */
	[NoInterfaceObject] interface NdefRecord {
	
		/**
		 * \brief The type of the record.
		 *
		 */
		readonly attribute unsigned short type;
		
		/**
		 * \brief The payload of the record.
		 *
		 */
		readonly attribute DOMString textPayload;
		
		/**
		 * \brief The payload of the record.
		 *
		 */
		readonly attribute ByteArray binaryPayload;
		
	};
	
	
	/**
	 * \brief Callback to be invoked when reading a Ndef message.
	 *
	 */
	[Callback=FunctionOnly, NoInterfaceObject] interface NdefSuccessCallback {
		void onSuccess(in NdefMessage obj);
	};
	
};

