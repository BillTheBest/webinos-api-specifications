/**
 * \brief The Generic Sensor API 
 *
 *
 *
 * The Webinos Generic Sensor API provides web applications with an API to access data from sensors in the device or connected to the device. 
 *
 * The API is agonostic to underlying methods for sensor discovery and communication with sensors.  
 *
 * The API consists of two interfaces: \n
 * - A sensor manager to get a list of available sensors and to initiate a selected sensor. \n
 * - A DOM level 3 event that provides sensor data.\n
 *
 * Currently 5 different sensor types are defined but the API could easily be extended with additional sensor types.
 * 
 * This is an experimental API and security and privacy issues are not addressed.
 * 
 *
 * \def-api-feature http://webinos.org/api/sensors
 * Acccess to all the module. This identifies which are the features that are exposed by this
 * module so that the developer can express a dependency on them.
 *
 * \author Claes Nilsson &lt;claes1.nilsson@sonyericsson.com&gt;
 * \version 0.4 
 */

module sensors {

  
 /**
   * \brief Array of Sensor value objects
   */
      typedef SensorValue[]  SensorValuesArray;


  /**
   * \brief Defines the  error codes for this module
   */
  exception SensorException {

     /**
       * \brief Illegal sensor id
       */
       const unsigned short INVALID_INPUT_ARGUMENT = 0; 
  };
 

   /**
   * \brief This interface defines the sensor manager interface
   * 
   * \code

       // Handle that can be used to cancel the ongoing asynchronous discovery process.
        var sensorHandle = 0;

        // Array of found temperature sensors object.
        var availableTempSensors = {};
                 
        // Callback method that display a list of found sensors in a selection list
        // The selection list is dynamically extended every time a new sensor is discovered.
        function sensorFoundCB(sensor) {

                var selectlist = document.getElementById('sensorlist');
                var option = document.createElement('option');
                option.value = sensor.uniqueId;
                option.appendChild(document.createTextNode(sensor.name));
	        availableTempSensors [sensor.uniqueId] = sensor;
                selectlist.appendChild(option);

        }
                      
        // Callback method that is invoked when user selects an option in the sensor selection list 
        function sensorSelected(sensor) {

                // Stops the getSensors operation
                sensorHandle.cancel();
                               
                // Configure the sensor. TBD

                // Start listening to sensor events and log values. 
                webinos.sensors.addEventListener(sensor.uniqueId, function (event) {
                          console.log(event.sensorValues[0].value);
                }, true); 
                
        }
        
        // Get list of temperature sensors registered in the device
        sensorHandle = webinos.sensors.getSensors(webinos.sensors.SensorType.SENSOR_TYPE_TEMPERATURE, sensorFoundCB);

        // Handle user selection of sensor
        var sensorlist = document.getElementById('sensorlist');
        sensorlist.addEventListener("change", function (e) {
				var sensor = availableTempSensors[e.target.value];
				if (sensor) {
				    sensorSelected(sensor);
				}
        }, false);


   * \endcode
   */  
   interface SensorManager {

      /**
       * \brief Returns an array of sensor objects (defining sensor properties) for all registered sensors of requested type.
       *
       * Note: It must be considered if this method is redundant to the general findServices() method in the Webinos ServiceDiscovery API.
       *
       * \code

       var availableTempSensors = webinos.sensors.getSensors(webinos.sensors.SensorType.SENSOR_TYPE_TEMPERATURE, foundSensor);
 
       function foundSensor(sensor) {

       	  alert("Thermometer found, named " + sensor.name);

       }
	
       * \endcode
       *
       *
       * \param sensorType Sensor type
       * \param successCB Callback issued when a sensor is found.  The callback is called every time a new sensor is found matching the sensorType.
       * \param errorCB Callback issued if getSensors fails.  
       * \param options Defines sensor search options.
       * \return A pending operation object making it possible to cancel the getSensorList operation
       * \throw SensorException with appropriate error code.
       */
       PendingOp getSensors (in unsigned short sensorType, in GetSensorsCB successCB, in optional SensorErrorCB errorCB, in optional GetSensorOptions options)
           raises (SensorException);     

      /**
       * \brief Configures a sensor identified by the uniqueId.
       *
       * Question: Do we need the ability to specify high and low thresholds? This is for example not supported by Android sensor API.
       *
       * \param uniqueId Unique id of the sensor.
       * \param options Sensor configuration options. 
       * \param successCB Callback issued when sensor configuration succeeded.
       * \param errorCB Callback issued if sensor configuration fails.  
       * \return A pending operation object making it possible to cancel the configureSensor operation     
       * \throw SensorException with appropriate error code.
       */
       PendingOp configureSensor (in DOMString uniqueId, in ConfigureSensorOptions options, in ConfigureSensorCB successCB, in optional SensorErrorCB errorCB)
           raises (SensorException);
  
      /**
       * \brief Adds a sensor event listener identified by the uniqueId.
       *
       *
       * \code
       *
       * // repeated
       *
       *  webinos.sensors.addEventListener(availableTempSensors[0].uniqueId, function (event) {
       *    console.log(event.sensorValues[0].value);
       *  }, true);
       *
       * // One-shot
       *
       *  function handler(event) {
       *     console.log(event.sensorValues[0].value);
       *  }
       *
       *  webinos.sensors.addEventListener(availableTempSensors[0].uniqueId, handler, true);
       *  webinos.sensors.removeEventListener(availableTempSensors[0].uniqueId, handler, true);
       * \endcode
       *
       * \param uniqueId Unique id of the sensor 
       * \param listener Event listener call back function (see http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/)
       * \param useCapture If true, useCapture indicates that the user wishes to add the event listener for the capture phase only,
       * i.e. this event listener will not be triggered during the target and bubbling phases. If false, the event listener will only be
       * triggered during the target and bubbling phases (see http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/)
       * 
       */
       void addEventListener (in DOMString uniqueId, in EventListener listener, in boolean useCapture);    
  
    };

   /**
    * \brief SensorType interface definition
    */
    interface SensorType {

     /**
      * \brief A constant describing all sensor types.
      * Could be used by getSensors to get properties for all registered sensor types.
      */
      const unsigned short SENSOR_TYPE_ALL = 0;

     /**
      * \brief A constant describing an ambient light sensor type.
      * Values:
      * sensorValue[0] = the measured ambient light level around the device in SI lux units.
      * Question: Do we also need max and min values and normalized value?
      */
      const unsigned short SENSOR_TYPE_LIGHT = 1;

     /**
      * \brief A constant describing an ambient noise sensor type.
      * Values:
      * sensorValue[0] = the measured ambient noise around the device, in DB(SPL).
      * Question: Do we also need max and min values and normalized value?
      */
      const unsigned short SENSOR_TYPE_NOISE = 2;

     /**
      * \brief A constant describing an ambient temperature sensor type.
      * Values:
      * sensorValue[0] = the measured ambient temperature around the device, in degrees Celsius.
      * Question: Do we also need max and min values and normalized value?
      */
      const unsigned short SENSOR_TYPE_TEMPERATURE = 3;

     /**
      * \brief A constant describing an atmospheric pressure sensor type.
      * Values:
      * sensorValue[0] = the measured atmospheric pressure around the device in hPa (millibar)
      * Question: Do we also need max and min values and normalized value?
      */
      const unsigned short SENSOR_TYPE_PRESSURE = 4;

     /**
      * \brief A constant describing a proximity sensor type.
      * Values:
      * sensorValue[0] =  Proximity sensor distance measured in centimeters
      * TBD: Need to state values for sensors that only can deliver "near" and "far" 
      */
      const unsigned short SENSOR_TYPE_PROXIMITY = 5;

     /**
      * \brief Should we support all Android sensor types? The internal accelerometer, gyro and magnetometer sensors are supported by the DeviceOrientation event. 
      * Should we add support for external accelerometer, gyro and magnetometer sensors with this generic API or should we add a parameter to DeviceOrientation
      * event that makes it possible to select external sensors to use?
      */

     /**
      * \brief type Defines the type of sensor.
      */
      attribute unsigned short type;
    };


   /**
    * \brief GetSensorsCB interface definition
    *
    */
    [Callback=FunctionOnly] interface GetSensorsCB {

      /**
       * \brief onSuccess The onSuccess method is called every time a new sensor is found during the getSensors() process.  
       * TBD Some detailed text...
       * \code
       * // Some code example
       * \endcode
       *
       *
       * \param sensor An input argument representing the found sensor.
       *
       */
       void onSuccess(in Sensor sensor);	  
    };

   /**
    * \brief ConfigureSensorCB interface definition
    *
    */
    [Callback=FunctionOnly] interface ConfigureSensorCB {

      /**
       * \brief onSuccess The onSuccess method is called when configuration of a sensor succeeded.  
       * TBD Some detailed text...
       * \code
       * // Some code example
       * \endcode
       *
       *
       *
       */
       void onSuccess();	  
    };


   /**
    * \brief SensorErrorCB interface definition
    *
    */
    [Callback=FunctionOnly] interface SensorErrorCB {

      /**
       * \brief onError The onError method is called if an error occurs during the getSensors() or configureSensor() process.  
       * TBD Some detailed text
       *
       * \code
	// Some code example
       * \endcode
       *
       * \param error The error object of an unsuccessful getSensors() asynchronous operation.
       *
       */
       void onErrror(in SensorCBError error); 
    };

   /**
    * \brief SensorCBError interface definition
    *
    */
    interface SensorCBError {

      /**
       * \brief Uknown error
       */
       const unsigned short UNKNOWN_ERROR = 0;

      /**
       * \brief No success callback within timeout period.
       */
       const unsigned short TIMEOUT_ERROR = 1;

      /**
       * \brief Illegal sensor type
       */
       const unsigned short ILLEGAL_SENSOR_TYPE_ERROR = 2;

      /**
       * \brief Illegal sensor type
       */
       const unsigned short SENSOR_TYPE_NOT_SUPPORTED_ERROR = 3;

      /**
       * \brief Illegal sensor id
       */
       const unsigned short ILLEGAL_SENSOR_ID_ERROR = 4;

      /**
       * \brief Other illegal input arguments
       */
       const unsigned short OTHER_ILLEGAL_INPUT_ARGUMENT_ERROR = 5;

      /**
       * \brief Sensor rate requested through configureSensor() not supported
       */
       const unsigned short REQUESTED_RATE_NOT_SUPPORTED_ERROR = 6;

     /**
       * \brief Interrupt mode requested through configureSensor() not supported
       */
       const unsigned short REQUESTED_INTERRUPTMODE_NOT_SUPPORTED_ERROR = 7;

     /**
       * \brief Permission denied
       */
       const unsigned short PERMISSION_DENIED_ERROR = 50;


      /**
       * \brief An error code assigned by an implementation when an error has occurred in getSensors() or configureSensor() processing.
       */
       readonly attribute unsigned short code;
    };    

   /**
    * \brief GetSensorOptions interface definition
    */
    interface GetSensorOptions {

      /**
       * \brief INFINITE Timeout Value
       *
       */
       const unsigned short INFINITE = 0;

      /**
       * \brief Defines a timeout value for when getSensors() is canceled in seconds. Default value is INFINITE.
       */
       attribute unsigned short timeout;
    };

  /**
    * \brief ConfigureSensorOptions interface definition
    */
    interface ConfigureSensorOptions {

      /**
       * \brief INFINITE Timeout Value
       *
       */
       const unsigned short INFINITE = 0;

      /**
       * \brief The sensor is reporting data as fast as possible.
       */
       const unsigned short SENSOR_DELAY_FASTEST = 0;

      /**
       * \brief The sensor is reporting data with a rate suitable for games.
       */
       const unsigned short SENSOR_DELAY_GAME = 1;

      /**
       * \brief The sensor is reporting data with a rate suitable for user interface.
       */
       const unsigned short SENSOR_DELAY_UI = 2;

      /**
       * \brief The sensor is reporting data with a normal rate, e.g. suitable for screen orientation changes.
       */
       const unsigned short SENSOR_DELAY_NORMAL = 3;

      /**
       * \brief Defines a timeout value for when configureSensors() is canceled in seconds. Default value is INFINITE.
       */
       attribute unsigned short timeout;

      /**
       * \brief The requested rate of the sensor data.
       */
       attribute unsigned short rate;

      /**
       * \brief The requested Interrupt mode of the sensor.\n
       * False = INTERRUPT_DISABLED (events fired with a fixed time interval) \n
       * True = INTERRUPT_ENABLED (events fired when value changes)
       */
       attribute boolean interrupt;
     };

    /**
     * \brief The PendingOp interface
     *
     * The PendingOp interface describes objects that are returned by asynchronous methods that are cancellable. It makes it possible to bring 
     * these operations to a stop if they haven't produced a result within a desired time or before a given event, thereby possibly reclaiming resources.
     * TBD: Elaborate on cancel of ongoing getSensors() operation...
     *
     */
     interface PendingOp {

    /**
     * \brief Method Cancel
     *
     *  Cancel the pending asynchronous operation. When this method is called, the user agent must immediately bring the operation to a stop and return.
     */
        void cancel ();
     };



   /**
    * \brief This interface defines sensor properties.
    * Attributes corresponds to Android sensor API - to be documented better
    */ 
 
    interface Sensor {
       /**
	* \brief Unique ID of sensor
	*/
	readonly attribute DOMString      uniqueId;

       /**
	* \brief Type of sensor
	*/
        readonly attribute unsigned short type;  

       /**
	* \brief Max range of sensor
	*/
    	readonly attribute float          maximumRange;

       /**
	* \brief Min delay of sensor
	*/
   	readonly attribute unsigned long   minDelay;

       /**
	* \brief Name of sensor
	*/
  	readonly attribute DOMString      name;

       /**
	* \brief Power consumption of sensor. TBD
	*/
   	readonly attribute float	  power;

       /**
	* \brief Resolution TBD
	*/
	readonly attribute float	  resolution;

       /**
	* \brief Vendor
	*/
	readonly attribute DOMString      vendor;  

       /**
	* \brief Version
	*/ 
   	readonly attribute unsigned long   version; 

     };


   /**
    * \brief This interface defines a sensor value.
    * 
    */ 
 

    interface SensorValue {

       /**
	* \brief Sensor value
	*/ 

       readonly attribute float value;
    };



  /**
   * \brief This interface defines the "genericsensor" event type.
   *
   *  Registration for generic sensor events is achieved by calling sensormanager.addEventListener with event type set to uniqueId of the selected sensor..
   * 
   *
   * 
   */

  interface SensorEvent : Event {

 
  /**
   * \brief A constant describing that the sensor is reporting data with maximum accuracy.
   */
    const unsigned short SENSOR_STATUS_ACCURACY_HIGH = 3;

  /**
   * \brief A constant describing that the sensor is reporting data with an average level of accuracy, calibrating with the environment may improve the
   * reading.
   */
    const unsigned short SENSOR_STATUS_ACCURACY_MEDIUM = 2;

  /**
   * \brief A constant describing that the sensor is reporting with low accuracy, calibrating with the environment is needed.
   */
    const unsigned short SENSOR_STATUS_ACCURACY_LOW = 1;

  /**
   * \brief A constant describing that the sensor data cannot be trusted, calibrating is needed or the environment does not allow reading.
   */
    const unsigned short SENSOR_STATUS_UNRELIABLE = 0;


  /**
   *  \brief The type of sensor 
   */
    readonly attribute SensorType sensorType;


  /**
   * \brief The accuracy of the sensor
   */
    readonly attribute unsigned short accuracy;

  /**
   * \brief The timestamp of the sensor. The time in nanosecond at which the event happened.
   */
    readonly attribute unsigned long? timestamp;

  /**
   * \brief The rate of the sensor data
   */
    readonly attribute unsigned short rate;

  /**
   *  \brief Interrupt mode of the sensor.
   *  The value is one of
   *  false = INTERRUPT_DISABLED (events fired with a fixed time interval)
   *  true = INTERRUPT_ENABLED (events fired when value changes)
   */
    readonly attribute boolean interrupt;

  /**
   * \brief Array of sensor values
   */
    readonly attribute SensorValuesArray sensorValues;

  /**
   * \brief Method to set initial values of sensor event
   * \code
   * // TBD
   * \endcode
   *   
   * \param uniqueId Unique id of sensor
   * \param bubbles True if event bubbles
   * \param cancelable True if event cancelable
   * \param sensorType Sensor type
   * \param accuracy Accuracy of sensor data
   * \param timestamp Timestamp 
   * \param rate Rate
   * \param interrupt Interrupt mode
   * \param sensorValues Array of sensor values
   */
    void initSensorEvent(in DOMString uniqueId,
                         in boolean bubbles,
                         in boolean cancelable,
                         in SensorType sensorType,
                         in unsigned short accuracy,
                         in unsigned long timestamp,
                         in unsigned short rate,
                         in boolean interrupt, 
                         in SensorValuesArray sensorValues); 
    };
};
