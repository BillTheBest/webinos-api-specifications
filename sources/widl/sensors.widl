/**
 * \brief The Generic Sensor API 
 *
 *
 *
 * The Webinos Generic Sensor API provides web applications with an API to access data from sensors in the device, connected to the device or in another device
 * device.
 *
 * The API is agonostic to underlying low level methods for sensor discovery and communication with sensors. However, the sensor API should be used
 * in combination with the the general Webinos service discovery methods findServices() and bind().  
 *
 * The API consists of two interfaces: \n
 * - A sensor manager to configure a selected sensor.\n
 * - A DOM level 3 event that provides sensor data.\n
 *
 * Currently 5 different sensor types are defined but the API could easily be extended with additional sensor types.
 * 
 * This is an experimental API and security and privacy issues are not specifically addressed in the specification. If access to security or privacy
 * sensitive sensors are provided the user agent must either acquire access permission through a user interface or control access through a prearranged
 * trust relationship with users. 
 *
 *
 * \def-api-feature http://webinos.org/api/sensors
 * Identifies all the sensor types. 
 *
 * \def-api-feature http://webinos.org/api/sensors.light
 * Identifies the light sensor type. 
 *
 * \def-api-feature http://webinos.org/api/sensors.noise
 * Identifies the noise sensor type. 
 *
 * \def-api-feature http://webinos.org/api/sensors.temperature
 * Identifies the temperature sensor type. 
 *
 * \def-api-feature http://webinos.org/api/sensors.pressure
 * Identifies the pressure sensor type. 
 *
 * \author Claes Nilsson &lt;claes1.nilsson@sonyericsson.com&gt;
 * \version 0.10 
 */

module sensors {

  
 /**
   * \brief Array of Sensor value objects
   */
      typedef SensorValue[]  SensorValuesArray;


  /**
   * \brief Defines the  error codes for this module
   */
  exception SensorException {

     /**
       * \brief Illegal sensor id
       */
       const unsigned short INVALID_INPUT_ARGUMENT = 0; 
  };
 

   /**
   * \brief This interface defines the sensor manager interface. Note that the Webinos ServiceDiscovery module findServices() and bind() methods are used to discover and provide access to sensors of a certain type. The sensors services can be located in the user's personal zone or be shared on the current network.
   * 
   * \code

        // Handle that can be used to cancel the ongoing asynchronous discovery process.
        var findHandle = 0;

        // Handle from service.bind.
        var sensorHandle = 0;

        // Array of found temperature sensors object.
        var availableTempSensors = {};
                 
        // Callback method that display a list of found sensors in a selection list
        // The selection list is dynamically extended every time a new sensor is discovered.
        function sensorFoundCB(sensor) {

                var selectlist = document.getElementById('sensorlist');
                var option = document.createElement('option');
                option.value = sensor.id;
                option.appendChild(document.createTextNode(sensor.displayName));
	        availableTempSensors [sensor.id] = sensor;
                selectlist.appendChild(option);

        }
                      
 
       // Callback when bind has been successfully executed on the service object. The Sensor is authorized and ready to use
        function bindCB(mySensor) {
 
               alert('Sensor ' + mySensor.displayName + ' with ID: ' + mySensor.id + ' ready to use');
               

                // Configure the sensor. TBD 

               
                // More may have to be done using the sensor attributes. 


                // Start listening to sensor events and log values. 
                mySensor.addEventListener('sensor', function (event) {
                          console.log(event.sensorValues[0]);

                          var temp = document.getElementById('temp');
                          temp.innerHTML = "Current temperature is: " + event.sensorValues[0];


                }, true); 

        }


       // Callback method that is invoked when user selects an option in the sensor selection list 
        function sensorSelected(sensor) {

                // Stops the findServices operation
                findHandle.cancel();

                // Binds to the sensor API to initiate an authorized objects used to
                // invoke services.  
                sensorHandle = sensor.bind({onBind:bindCB});                               
                
        }
        
        // Get list of temperature sensors registered in the device through the Service Discovery findServices() method
        findHandle  = window.webinos.findServices({api:'http://webinos.org/api/sensors.temperature'}, {onFound:sensorFoundCB});
 
       // Handle user selection of sensor
        var sensorlist = document.getElementById('sensorlist');
        sensorlist.addEventListener("change", function (e) {
				var sensor = availableTempSensors[e.target.value];
				if (sensor) {
				    sensorSelected(sensor);
				}
        }, false);


   * \endcode
   */  
   [NoInterfaceObject] interface SensorManager {


      /**
       * \brief Configures a sensor identified by the uniqueId.
       *
       * Question: Do we need the ability to specify high and low thresholds? This is for example not supported by Android sensor API.
       *
       * \param uniqueId Unique id of the sensor.
       * \param options Sensor configuration options. 
       * \param successCB Callback issued when sensor configuration succeeded.
       * \param errorCB Callback issued if sensor configuration fails.  
       * \return A pending operation object making it possible to cancel the configureSensor operation     
       * \throw SensorException with appropriate error code.
       */
       PendingOp configureSensor (in DOMString uniqueId, in ConfigureSensorOptions options, in ConfigureSensorCB successCB, in optional SensorErrorCB errorCB)
           raises (SensorException);
  
 
    };


   /**
    * \brief ConfigureSensorCB interface definition
    *
    */
    [Callback=FunctionOnly, NoInterfaceObject] interface ConfigureSensorCB {

      /**
       * \brief onSuccess The onSuccess method is called when configuration of a sensor succeeded.  
       *
       */
       void onSuccess();	  
    };


   /**
    * \brief SensorErrorCB interface definition
    *
    */
    [Callback=FunctionOnly, NoInterfaceObject] interface SensorErrorCB {

      /**
       * \brief onError The onError method is called if an error occurs during the configureSensor() process.  
       *
       *
       * \param error The error object of an unsuccessful configureSensor() asynchronous operation.
       *
       */
       void onErrror(in SensorCBError error); 
    };

   /**
    * \brief SensorCBError interface definition
    *
    */
    [NoInterfaceObject] interface SensorCBError {

      /**
       * \brief Uknown error
       */
       const unsigned short UNKNOWN_ERROR = 0;

      /**
       * \brief No success callback within timeout period.
       */
       const unsigned short TIMEOUT_ERROR = 1;

      /**
       * \brief Illegal sensor type
       */
       const unsigned short ILLEGAL_SENSOR_TYPE_ERROR = 2;

      /**
       * \brief Illegal sensor type
       */
       const unsigned short SENSOR_TYPE_NOT_SUPPORTED_ERROR = 3;

      /**
       * \brief Illegal sensor id
       */
       const unsigned short ILLEGAL_SENSOR_ID_ERROR = 4;

      /**
       * \brief Other illegal input arguments
       */
       const unsigned short OTHER_ILLEGAL_INPUT_ARGUMENT_ERROR = 5;

      /**
       * \brief Sensor rate requested through configureSensor() not supported
       */
       const unsigned short REQUESTED_RATE_NOT_SUPPORTED_ERROR = 6;

     /**
       * \brief Interrupt mode requested through configureSensor() not supported
       */
       const unsigned short REQUESTED_INTERRUPTMODE_NOT_SUPPORTED_ERROR = 7;

     /**
       * \brief Permission denied
       */
       const unsigned short PERMISSION_DENIED_ERROR = 50;


      /**
       * \brief An error code assigned by an implementation when an error has occurred in configureSensor() processing.
       */
       readonly attribute unsigned short code;
    };    


  /**
    * \brief ConfigureSensorOptions interface definition
    */
    [NoInterfaceObject] interface ConfigureSensorOptions {

      /**
       * \brief INFINITE Timeout Value
       *
       */
       const unsigned short INFINITE = 0;

      /**
       * \brief The sensor is reporting data as fast as possible.
       */
       const unsigned short SENSOR_DELAY_FASTEST = 0;

      /**
       * \brief The sensor is reporting data with a rate suitable for games.
       */
       const unsigned short SENSOR_DELAY_GAME = 1;

      /**
       * \brief The sensor is reporting data with a rate suitable for user interface.
       */
       const unsigned short SENSOR_DELAY_UI = 2;

      /**
       * \brief The sensor is reporting data with a normal rate, e.g. suitable for screen orientation changes.
       */
       const unsigned short SENSOR_DELAY_NORMAL = 3;

      /**
       * \brief Defines a timeout value for when configureSensors() is canceled in seconds. Default value is INFINITE.
       */
       attribute unsigned short timeout;

      /**
       * \brief The requested rate of the sensor data.
       */
       attribute unsigned short rate;

      /**
       * \brief The requested Interrupt mode of the sensor.\n
       * False = INTERRUPT_DISABLED (events fired with a fixed time interval) \n
       * True = INTERRUPT_ENABLED (events fired when value changes)
       */
       attribute boolean interrupt;
     };

    /**
     * \brief The PendingOp interface
     *
     * The PendingOp interface describes objects that are returned by asynchronous methods that are cancellable. It makes it possible to bring 
     * these operations to a stop if they haven't produced a result within a desired time or before a given event, thereby possibly reclaiming resources.\n
     * TBD: Elaborate on cancel of ongoing configureSensor() operation...
     *
     */
     [NoInterfaceObject] interface PendingOp {

    /**
     * \brief Method Cancel
     *
     *  Cancel the pending asynchronous operation. When this method is called, the user agent must immediately bring the operation to a stop and return. No success or error callback for the pending operation will be invoked.
     */
        void cancel ();
     };



   /**
    * \brief This interface defines sensor properties. It is a sensor specific extension to the interface Service in the ServiceDiscovery module.
    * The added attributes correspond to Android sensor API attributes.
    */ 
 
    [NoInterfaceObject] interface Sensor : Service {
 
       /**
	* \brief Max range of sensor in the sensors unit.
	*/
    	readonly attribute float?          maximumRange;

       /**
	* \brief Min delay of sensor allowed between two events in microsecond or zero if this sensor only returns a value when the data it's measuring changes.
	*/
   	readonly attribute unsigned long?   minDelay;

       /**
	* \brief Power consumption of sensor in mA used by this sensor while in use. 
	*/
   	readonly attribute float?	  power;

       /**
	* \brief Resolution of the sensor in the sensors unit.
	*/
	readonly attribute float?	  resolution;

       /**
	* \brief Vendor string of this sensor.
	*/
	readonly attribute DOMString?      vendor;  

       /**
	* \brief Version of the sensors module.
	*/ 
   	readonly attribute unsigned long?  version; 

     };


   /**
    * \brief This interface defines a sensor value.
    * 
    */ 
 

    [NoInterfaceObject] interface SensorValue {

       /**
	* \brief Sensor value
	*/ 

       readonly attribute float value;
    };



  /**
   * \brief This interface defines the "genericsensor" event type.
   *
   *  Registration for generic sensor events is achieved by calling addEventListener instantiated on the selected sensor object with event type set to "sensor" (see code example in the beginning of this specification)
   * 
   *
   * 
   */

   [NoInterfaceObject] interface SensorEvent : Event {

 
  /**
   * \brief A constant describing that the sensor is reporting data with maximum accuracy.
   */
    const unsigned short SENSOR_STATUS_ACCURACY_HIGH = 4;

  /**
   * \brief A constant describing that the sensor is reporting data with an average level of accuracy, calibrating with the environment may improve the
   * reading.
   */
    const unsigned short SENSOR_STATUS_ACCURACY_MEDIUM = 3;

  /**
   * \brief A constant describing that the sensor is reporting with low accuracy, calibrating with the environment is needed.
   */
    const unsigned short SENSOR_STATUS_ACCURACY_LOW = 2;

  /**
   * \brief A constant describing that the sensor data cannot be trusted, calibrating is needed or the environment does not allow reading.
   */
    const unsigned short SENSOR_STATUS_UNRELIABLE = 1;

 /**
   * \brief A constant describing that the sensor is not available and no sensor data can be provided. This accuracy attribute will for example take 
   * this value when contact is lost with a sensor using Bluetooth communication.
   */
    const unsigned short SENSOR_STATUS_UNAVAILABLE = 0;


  /**
   *  \brief The type of sensor. This is a URI defining the sensor type according to the defined sensor "feature" URI strings. See section "Features". \n
   *\n
   * For the defined sensor types the sensorValues array contains the following data:\n
   *\n
   * http://webinos.org/api/sensors.light:\n
   * sensorValue[0] = the measured ambient light level around the device in SI lux units.\n
   * sensorValue[1] = A normalized value between 0 and 1.\n
   *\n
   * http://webinos.org/api/sensors.noise:\n
   * sensorValue[0] = the measured ambient noise around the device, in DB(SPL).\n
   * sensorValue[1] = A normalized value between 0 and 1.\n
   *\n
   * http://webinos.org/api/sensors.temperature:\n
   * sensorValue[0] = the measured ambient temperature around the device, in degrees Celsius.\n
   * sensorValue[1] = A normalized value between 0 and 1.\n
   *\n
   * http://webinos.org/api/sensors.pressure:\n
   * sensorValue[0] = the measured atmospheric pressure around the device in hPa (millibar)\n
   * sensorValue[1] = A normalized value between 0 and 1.\n
   *\n
   * http://webinos.org/api/sensors.proximity:\n
   * sensorValue[0] =  Proximity sensor distance measured in centimeters.\n
   * sensorValue[1] = A normalized value between 0 and 1.Some sensor can only state "near" (o) and "far" (1) \n
   *   
   */
    readonly attribute DOMString sensorType;

  /**
   * \brief The unique identity of the of the specific sensor
   */
    readonly attribute DOMString sensorId;


  /**
   * \brief The accuracy of the sensor
   */
    readonly attribute unsigned short accuracy;

 
  /**
   * \brief The rate of the sensor data
   */
    readonly attribute unsigned short rate;

  /**
   *  \brief Interrupt mode of the sensor.
   *  The value is one of
   *  false = INTERRUPT_DISABLED (events fired with a fixed time interval)
   *  true = INTERRUPT_ENABLED (events fired when value changes)
   */
    readonly attribute boolean interrupt;

  /**
   * \brief Array of sensor values
   */
    readonly attribute SensorValuesArray sensorValues;

  /**
   * \brief Method to set initial values of sensor event.  
   *
   * The initSensorEvent() method must initialize the event in a manner analogous to the initEvent() method in http://www.w3.org/TR/2010/WD-DOM-Level-3-Events-20100907/.
   * The method can for example be used with document.createEvent() and EventTarget.dispatchEvent() to simulate a specific event.
   * The sensorType, sensorId, accuracy, rate, interrupt and sensorvalues arguments must initialize the attributes with the same names.
   *   
   * \param type Event type i.e. 'sensor'
   * \param bubbles True if event bubbles
   * \param cancelable True if event cancelable
   * \param sensorType Sensor type as a URI
   * \param sensorId The unique identity of the specific sensor
   * \param accuracy Accuracy of sensor data
   * \param rate Rate
   * \param interrupt Interrupt mode
   * \param sensorValues Array of sensor values
   */
    void initSensorEvent(in DOMString type,
                         in boolean bubbles,
                         in boolean cancelable,
                         in DOMString sensorType,
                         in DOMString sensorId,
                         in unsigned short accuracy,
                         in unsigned short rate,
                         in boolean interrupt, 
                         in SensorValuesArray sensorValues); 
    };
};
