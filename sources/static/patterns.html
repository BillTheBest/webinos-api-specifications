<!DOCTYPE html PUBLIC "html">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<!--<link media="screen" href="deviceapis.css" type="text/css" rel="stylesheet">-->
<!--<script type="text/javascript" src="deviceapis.js"></script>-->
<title>Device APIs - Design Patterns & Guidelines</title>

<style>

#content pre {
    text-align: left;
        font-family: 'Droid Sans Mono', Courier;        
    font-family: "Consolas", "Lucida Sans Unicode", "Monaco", "Courier New", Courier, mono, serif;
    -webkit-border-radius: 8px;
    -khtml-border-radius: 8px;
    -moz-border-radius: 8px;
    border-radius: 8px;
    border: 1px solid rgba(255, 255, 255, 0.2);
    display:block;
    color:#2c3123;
    margin:15px 0px 15px -8px;
    padding:12px 20px 12px 35px;
    font-size: 14px;
    overflow:hidden;
    word-wrap:break-word;
}



#content pre code { font-family: 'Droid Sans Mono', Courier;        
    font-family: "Consolas", "Lucida Sans Unicode", "Monaco", "Courier New", Courier, mono, serif;
    font-size: 1em;
    margin:0px;
    11px;
    padding: 2px; 
    border: 1px solid #888;
}

#content pre webidl {
    font-family: 'Droid Sans Mono', Courier;        
    font-family: "Consolas", "Lucida Sans Unicode", "Monaco", "Courier New", Courier, mono, serif;
    font-size: 1em;
    margin:0px;
    11px;
    padding: 2px; 
    border: 1px solid #888;
}

#content .prettyprint {
}


#content .signature {
  background-color: #EFF6F1;
}

#content .examplecode {
  background-color: #D5E9F9;
}

#content .webidl {
  background-color: #FCF2F2;
}

#content pre.signature::before {
    content:    "Method Signature";
    display:    block;
    background: #007900;
    width: 200px;
    color:  #fff;
    font-family:    "Helvetica";
    padding:    3px;
    font-weight:    bold;
    margin: -1em 0 1em -1em;
    padding: 2px; 
    border: 1px solid #888;
}

#content pre.examplecode::before {
    content:    "Code Example";
    display:    block;
    background: #00C;
    width: 200px;
    color:  #fff;
    font-family:    "Helvetica";
    padding:    3px;
    font-weight:    bold;
    margin: -1em 0 1em -1em;
}

#content pre.webidl::before {
    content:    "WebIDL Specification";
    display:    block;
    background: #C00;
    width: 200px;
    color:  #fff;
    font-family:    "Helvetica";
    padding:    3px;
    font-weight:    bold;
    margin: -1em 0 1em -1em;
}

      #content .prettyprint b {
        font-weight: normal;
        color: #c61800;
        text-shadow: #c61800 0 0 1px;
        /*letter-spacing: -1px;*/
      }


      #content pre select {
        font-family: Monaco, Courier;
        border: 1px solid #c61800;
      }
        
      #content input {
        font-size: 16px;
        margin-right: 10px;
        font-family: Helvetica;
        padding: 3px;
      }
      #content input[type="range"] {
        width: 100%;
      }
      
      #content button {
        margin: 20px 10px 0 0;
        font-family: Verdana;
      }
      
      #content button.large {
        font-size: 32px;
      }
        
      #content pre b {
        font-weight: normal;
        color: #c61800;
        text-shadow: #c61800 0 0 1px;
        /*letter-spacing: -1px;*/
      }
      #content pre em {
        font-weight: normal;
        font-style: normal;
        color: #18a600;
        text-shadow: #18a600 0 0 1px;
      }
      #content pre input[type="range"] {
        height: 6px;
        cursor: pointer;
        width: auto;
      }



#content {
	font-size: 1.1em;
	counter-reset: assertion;
}

#content .product, #content .product-ua, #content .product-cc {
}

#content dfn.external {
	font-weight: normal;
	font-style: italic;
}

#content pre.idl {
	border:solid thin;
	background:#eee;
	color:#000;
	padding:0.5em
}

#content pre.idl :link, #content pre.idl :visited {
	color:inherit;
	background:transparent
}

#content dfn {
	font-style:normal;
	font-weight:bolder;
}
#content em.ct, #content em.ct-samp {
	text-transform:uppercase;
	font-style:normal;
	font-weight:normal;
}

#content .issue {
    padding:    1em;
    border: 1px solid #f00;
    background: #ffc;
}
 
#content .issue::before {
    content:    "Issue";
    display:    block;
    width:  150px;
    margin: -1.5em 0 0.5em 0;
    font-weight:    bold;
    border: 1px solid #f00;
    background: #fff;
    padding:    3px 1em;
}

#content .comment {
    padding:    1em;
    border: 1px solid #f00;
    background: #fff	;
}
 
#content .comment::before {
    content:    "Comment";
    display:    block;
    width:  150px;
    margin: -1.5em 0 0.5em 0;
    font-weight:    bold;
    border: 1px solid #f00;
    background: #fff;
    padding:    3px 1em;
}

#content .ws3 {
    padding:    1em;
    border: 1px solid #f00;
    background: lightblue;
}
 
#content .ws3::before {
    content:    "For WS3 Review";
    display:    block;
    width:  150px;
    margin: -1.5em 0 0.5em 0;
    font-weight:    bold;
    border: 1px solid #f00;
    background: #fff;
    padding:    3px 1em;
}

#content .ws4 {
    padding:    1em;
    border: 1px solid #f00;
    background: lightblue;
}
 
#content .ws4::before {
    content:    "Under discussion";
    display:    block;
    width:  150px;
    margin: -1.5em 0 0.5em 0;
    font-weight:    bold;
    border: 1px solid #f00;
    background: #fff;
    padding:    3px 1em;
}

#content .note {
	margin-left: 2em;
	border: 2px solid #CFF6D9;
	padding: .5em;
	padding-top: 0px;
	padding-bottom: 1em;
	color: #444;
	background-color: #E2FFF0;
	font-size: 0.8em;
}

#content dd > dl {
	margin:0px;
	padding:0px
}

#content code {
	font-size: 1.1em;
	text-decoration: none;
	color: #002108;
}


#content .dir_listing li {
	list-style-type:none;
	font-family: Tahoma, Arial, Helvetica, sans-serif;
}

#content span span {
	background-color: yellow;
}

#content li.folder {
	list-style-image:url(images/expanded_folder.png)
}

#content .authorguide {
	border: 1px solid #67BBB5;
	background:#E8EBFC;
	padding: 1em;
	font-size: .9em;
	color: #003;
}

#content .authorguide strong {
	padding: .2em;
	color: #003;
	border: none;
	position:relative;
	display: block;
	width: 200px;
	left: -1.5em;
	top: -1.5em;
	background: #C6D8E6;
	text-align: center;
}

#content span.notetitle {
	padding: .2em;
	color:#066;
	border: none;
	position:relative;
	display: block;
	width: 40px;
	left: -1.5em;
	top: -.7em;
	background: #F2FFF1;
	padding-left: .2em;
	text-align: center;
}

#content var {
	font-family: "Lucida Console", Monaco, monospace;
}

#content li.folder li {
	list-style-image: none;
}

#content .dir_listing .comment {
	border: none;
	font-family:"Courier New", Courier, monospace;
	color: #669933;
}

#content .dir_listing img {
	vertical-align: middle;
}

#content .redNote {
	color: red;
}

#content dl.procedure dt {
	font-weight: normal;
}

#content .editorialNote {
	padding: 5px;
	background-color: #F3B9B7;
	border: 3px dashed #FFEEB8;
	color: #444;
	font-size:0.8em;
}

#content li>ol {
	list-style-type:upper-alpha;
}

#content p[id]:after {
	font-size: .8em;
}

#content table.webinos {
	border-width: 1px;
	border-spacing: 2px;
	border-style: outset;
	border-color: #808080;
	border-collapse: collapse;
	background-color: #ffffff;
}

#content table.webinos th {
	border-width: 1px;
	padding: 1px;
	border-style: inset;
	border-color: #808080;
	background-color: #ffffff;
	-moz-border-radius: ;
}

#content table.webinos td {
	vertical-align: top;
	border-width: 1px;
	padding: 1px;
	border-style: inset;
	border-color: #808080;
	background-color: #ffffff;
	-moz-border-radius: ;
}

#content .webinosreqid {
	font-weight:bold;
}

#content .webinoseqid_ext {
	font-weight:bold;
}

#content webinosreqtext {
	font-style:normal;
}
	
/* Table styles */
#content table {
          border-spacing: 0;
          border-collapse:    collapse;
          border-bottom:  3px solid #005a9c;
          margin-bottom:  1em;
      }
 
#content th {
          background: #005a9c;
          color:  #fff;
          padding:    3px 5px;
          text-align: left;
          border-right: 1px solid #ddd;
      }
 
#content  th[scope="row"] {
          background: inherit;
          color:  inherit;
          border-top: 1px solid #ddd;
      }
 
#content  td {
          padding:    3px 10px;
          border-top: 1px solid #ddd;
          border-right: 1px solid #ddd;
      }
 
#content th:last-of-type, td:last-of-type {
          border-right: none;
      }
 
#content tr:nth-child(even) {
          background: #f0f6ff;
      }

#content .attrName, .methodName {
    background: #ffffd2;
}


	#content  {
	  padding: 2em 1em 2em 70px;
	  margin: 0;
	  font-family: sans-serif;
	  color: black;
	  background: white;
	  background-position: top left;
	  background-attachment: fixed;
	  background-repeat: no-repeat;
	}

	#content :link { color: #00C; background: transparent }
	#content :visited { color: #609; background: transparent }
	#content a:active { color: #C00; background: transparent }

	#content a:link img, #content a:visited img { border-style: none } /* no border on img links */

	#content a img { color: white; }        /* trick to hide the border in Netscape 4 */
	@media all {                   /* hide the next rule from Netscape 4 */
	#content   a img { color: inherit; }    /* undo the color change above */
	}

	#content th, #content td { /* ns 4 */
	  font-family: sans-serif;
	}

	#content h1, #content h2, #content h3, #content h4, #content h5, #content h6 { text-align: left }
	/* background should be transparent, but WebTV has a bug */
	#content h1, #content h2, #content h3 { color: #005A9C; background: white; padding-top: 0.2em }
	#content h1 { font: 170% sans-serif }
	#content h2 { font: 140% sans-serif }
	#content h3 { font: 120% sans-serif }
	#content h4 { font: bold 100% sans-serif }
	#content h5 { font: bold italic 100% sans-serif }
	#content h6 { font: bold small-caps 100% sans-serif }


	#content .hide { display: none }

	#content div.head { margin-bottom: 1em }
	#content div.head h1 { margin-top: 2em; clear: both }
	#content div.head table { margin-left: 2em; margin-top: 2em }

	#content p.copyright { font-size: small }
	#content p.copyright small { font-size: small }


	#content a[href] img:hover { background:white}

	@media screen {  /* hide from IE3 */
	#content a[href]:hover { background: #ffa }
	}

	#content pre { margin-left: 2em }
	/*
	#content  p {
	  margin-top: 0.6em;
	  margin-bottom: 0.6em;
	}
	*/
	#content dt, #content dd { margin-top: 0; margin-bottom: 0 } /* opera 3.50 */

	#content pre, #content code { font-family: monospace } /* navigator 4 requires this */

	#content ul.toc, #content ol.toc {
	  list-style: disc;		/* Mac NS has problem with 'none' */
	  list-style: none;
	}

	@media aural {  
	  #content h1, #content h2, #content h3 { stress: 20; richness: 90 }
	  #content .hide { speak: none }
	  #content p.copyright { volume: x-soft; speech-rate: x-fast }
	  #content dt { pause-before: 20% }
	  #content pre { speak-punctuation: code } 
	}



	#content  {
	}



#content .toc {
    list-style-type: none;
}

#content div.exampleInner pre { margin-left: 1em; margin-top: 0em; margin-bottom: 0em}
#content div.exampleOuter {border: 4px double gray; margin: 0em; padding: 0em}
#content div.exampleInner { background-color: #d5dee3;
     	           border-top-width: 4px;
       	           border-top-style: double;
       	           border-top-color: #d3d3d3;
       	           border-bottom-width: 4px;
       	           border-bottom-style: double;
       	           border-bottom-color: #d3d3d3;
       	           padding: 4px; margin: 0em }
#content div.exampleWrapper { margin: 4px }
#content div.exampleHeader { font-weight: bold; margin: 4px}



#content .def-api-feature dt, #content dt .def-device-cap, #content dt.const code { font: bold 100% sans-serif; }
#content dt.attribute code, #content dt.method code { font: italic 100% sans-serif; }

#content .def-device-caps dd { margin-bottom: 2em }

#content dt.method { margin-top: 2em }

#content .summary td {
    text-align: left;
    background-color: white;
    color: inherit;
    font-family: monospace;
    white-space:pre;
    padding: .3em 1em .3em 1em;
}
/* Pretty printing styles. Used with prettify.js. */

#content .str { color: #080; }
#content .kwd { color: #008; }
#content .com { color: #800; }
#content .typ { color: #606; }
#content .lit { color: #066; }
#content .pun { color: #660; }
#content .pln { color: #000; }
#content .tag { color: #008; }
#content .atn { color: #606; }
#content .atv { color: #080; }
#content .dec { color: #606; }

/* Specify class=linenums on a pre to get line numbering */
#content ol.linenums { margin-top: 0; margin-bottom: 0 } /* IE indents via margin-left */
#content li.L0,
#content li.L1,
#content li.L2,
#content li.L3,
#content li.L5,
#content li.L6,
#content li.L7,
#content li.L8 { list-style-type: none }
/* Alternate shading for lines */
#content li.L1,
#content li.L3,
#content li.L5,
#content li.L7,
#content li.L9 { background: #eee }

/*@media print {*/
  #content .str { color: #060; }
  #content .kwd { color: #006; font-weight: bold; }
  #content .com { color: #600; font-style: italic; }
  #content .typ { color: #404; font-weight: bold; }
  #content .lit { color: #044; }
  #content .pun { color: #440; }
  #content .pln { color: #000; }
  #content .tag { color: #006; font-weight: bold; }
  #content .atn { color: #404; }
  #content .atv { color: #060; }
/*}*/


</style>

<script>
// Copyright (C) 2006 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


/**
 * @fileoverview
 * some functions for browser-side pretty printing of code contained in html.
 * <p>
 *
 * For a fairly comprehensive set of languages see the
 * <a href="http://google-code-prettify.googlecode.com/svn/trunk/README.html#langs">README</a>
 * file that came with this source.  At a minimum, the lexer should work on a
 * number of languages including C and friends, Java, Python, Bash, SQL, HTML,
 * XML, CSS, Javascript, and Makefiles.  It works passably on Ruby, PHP and Awk
 * and a subset of Perl, but, because of commenting conventions, doesn't work on
 * Smalltalk, Lisp-like, or CAML-like languages without an explicit lang class.
 * <p>
 * Usage: <ol>
 * <li> include this source file in an html page via
 * <li> define style rules.  See the example page for examples.
 * <li> mark the {@code <pre>} and {@code <code>} tags in your source with
 *    {@code class=prettyprint.}
 *    You can also use the (html deprecated) {@code <xmp>} tag, but the pretty
 *    printer needs to do more substantial DOM manipulations to support that, so
 *    some css styles may not be preserved.
 * </ol>
 * That's it.  I wanted to keep the API as simple as possible, so there's no
 * need to specify which language the code is in, but if you wish, you can add
 * another class to the {@code <pre>} or {@code <code>} element to specify the
 * language, as in {@code <pre class="prettyprint lang-java">}.  Any class that
 * starts with "lang-" followed by a file extension, specifies the file type.
 * See the "lang-*.js" files in this directory for code that implements
 * per-language file handlers.
 * <p>
 * Change log:<br>
 * cbeust, 2006/08/22
 * <blockquote>
 *   Java annotations (start with "@") are now captured as literals ("lit")
 * </blockquote>
 * @requires console
 */

// JSLint declarations
/*global console, document, navigator, setTimeout, window */

/**
 * Split {@code prettyPrint} into multiple timeouts so as not to interfere with
 * UI events.
 * If set to {@code false}, {@code prettyPrint()} is synchronous.
 */
window['PR_SHOULD_USE_CONTINUATION'] = true;

/** the number of characters between tab columns */
window['PR_TAB_WIDTH'] = 8;

/** Walks the DOM returning a properly escaped version of innerHTML.
  * @param {Node} node
  * @param {Array.<string>} out output buffer that receives chunks of HTML.
  */
window['PR_normalizedHtml']

/** Contains functions for creating and registering new language handlers.
  * @type {Object}
  */
  = window['PR']

/** Pretty print a chunk of code.
  *
  * @param {string} sourceCodeHtml code as html
  * @return {string} code as html, but prettier
  */
  = window['prettyPrintOne']
/** Find all the {@code <pre>} and {@code <code>} tags in the DOM with
  * {@code class=prettyprint} and prettify them.
  * @param {Function?} opt_whenDone if specified, called when the last entry
  *     has been finished.
  */
  = window['prettyPrint'] = void 0;

/** browser detection. @extern @returns false if not IE, otherwise the major version. */
window['_pr_isIE6'] = function () {
  var ieVersion = navigator && navigator.userAgent &&
      navigator.userAgent.match(/\bMSIE ([678])\./);
  ieVersion = ieVersion ? +ieVersion[1] : false;
  window['_pr_isIE6'] = function () { return ieVersion; };
  return ieVersion;
};


(function () {
  // Keyword lists for various languages.
  var FLOW_CONTROL_KEYWORDS =
      "break continue do else for if return while ";
  var C_KEYWORDS = FLOW_CONTROL_KEYWORDS + "auto case char const default " +
      "double enum extern float goto int long register short signed sizeof " +
      "static struct switch typedef union unsigned void volatile ";
  var COMMON_KEYWORDS = C_KEYWORDS + "catch class delete false import " +
      "new operator private protected public this throw true try typeof ";
  var CPP_KEYWORDS = COMMON_KEYWORDS + "alignof align_union asm axiom bool " +
      "concept concept_map const_cast constexpr decltype " +
      "dynamic_cast explicit export friend inline late_check " +
      "mutable namespace nullptr reinterpret_cast static_assert static_cast " +
      "template typeid typename using virtual wchar_t where ";
  var JAVA_KEYWORDS = COMMON_KEYWORDS +
      "abstract boolean byte extends final finally implements import " +
      "instanceof null native package strictfp super synchronized throws " +
      "transient ";
  var CSHARP_KEYWORDS = JAVA_KEYWORDS +
      "as base by checked decimal delegate descending event " +
      "fixed foreach from group implicit in interface internal into is lock " +
      "object out override orderby params partial readonly ref sbyte sealed " +
      "stackalloc string select uint ulong unchecked unsafe ushort var ";
  var JSCRIPT_KEYWORDS = COMMON_KEYWORDS +
      "debugger eval export function get null set undefined var with " +
      "Infinity NaN ";
  var PERL_KEYWORDS = "caller delete die do dump elsif eval exit foreach for " +
      "goto if import last local my next no our print package redo require " +
      "sub undef unless until use wantarray while BEGIN END ";
  var PYTHON_KEYWORDS = FLOW_CONTROL_KEYWORDS + "and as assert class def del " +
      "elif except exec finally from global import in is lambda " +
      "nonlocal not or pass print raise try with yield " +
      "False True None ";
  var RUBY_KEYWORDS = FLOW_CONTROL_KEYWORDS + "alias and begin case class def" +
      " defined elsif end ensure false in module next nil not or redo rescue " +
      "retry self super then true undef unless until when yield BEGIN END ";
  var SH_KEYWORDS = FLOW_CONTROL_KEYWORDS + "case done elif esac eval fi " +
      "function in local set then until ";
  var ALL_KEYWORDS = (
      CPP_KEYWORDS + CSHARP_KEYWORDS + JSCRIPT_KEYWORDS + PERL_KEYWORDS +
      PYTHON_KEYWORDS + RUBY_KEYWORDS + SH_KEYWORDS);

  // token style names.  correspond to css classes
  /** token style for a string literal */
  var PR_STRING = 'str';
  /** token style for a keyword */
  var PR_KEYWORD = 'kwd';
  /** token style for a comment */
  var PR_COMMENT = 'com';
  /** token style for a type */
  var PR_TYPE = 'typ';
  /** token style for a literal value.  e.g. 1, null, true. */
  var PR_LITERAL = 'lit';
  /** token style for a punctuation string. */
  var PR_PUNCTUATION = 'pun';
  /** token style for a punctuation string. */
  var PR_PLAIN = 'pln';

  /** token style for an sgml tag. */
  var PR_TAG = 'tag';
  /** token style for a markup declaration such as a DOCTYPE. */
  var PR_DECLARATION = 'dec';
  /** token style for embedded source. */
  var PR_SOURCE = 'src';
  /** token style for an sgml attribute name. */
  var PR_ATTRIB_NAME = 'atn';
  /** token style for an sgml attribute value. */
  var PR_ATTRIB_VALUE = 'atv';

  /**
   * A class that indicates a section of markup that is not code, e.g. to allow
   * embedding of line numbers within code listings.
   */
  var PR_NOCODE = 'nocode';

  /** A set of tokens that can precede a regular expression literal in
    * javascript.
    * http://www.mozilla.org/js/language/js20/rationale/syntax.html has the full
    * list, but I've removed ones that might be problematic when seen in
    * languages that don't support regular expression literals.
    *
    * <p>Specifically, I've removed any keywords that can't precede a regexp
    * literal in a syntactically legal javascript program, and I've removed the
    * "in" keyword since it's not a keyword in many languages, and might be used
    * as a count of inches.
    *
    * <p>The link a above does not accurately describe EcmaScript rules since
    * it fails to distinguish between (a=++/b/i) and (a++/b/i) but it works
    * very well in practice.
    *
    * @private
    */
  var REGEXP_PRECEDER_PATTERN = function () {
      var preceders = [
          "!", "!=", "!==", "#", "%", "%=", "&", "&&", "&&=",
          "&=", "(", "*", "*=", /* "+", */ "+=", ",", /* "-", */ "-=",
          "->", /*".", "..", "...", handled below */ "/", "/=", ":", "::", ";",
          "<", "<<", "<<=", "<=", "=", "==", "===", ">",
          ">=", ">>", ">>=", ">>>", ">>>=", "?", "@", "[",
          "^", "^=", "^^", "^^=", "{", "|", "|=", "||",
          "||=", "~" /* handles =~ and !~ */,
          "break", "case", "continue", "delete",
          "do", "else", "finally", "instanceof",
          "return", "throw", "try", "typeof"
          ];
      var pattern = '(?:^^|[+-]';
      for (var i = 0; i < preceders.length; ++i) {
        pattern += '|' + preceders[i].replace(/([^=<>:&a-z])/g, '\\$1');
      }
      pattern += ')\\s*';  // matches at end, and matches empty string
      return pattern;
      // CAVEAT: this does not properly handle the case where a regular
      // expression immediately follows another since a regular expression may
      // have flags for case-sensitivity and the like.  Having regexp tokens
      // adjacent is not valid in any language I'm aware of, so I'm punting.
      // TODO: maybe style special characters inside a regexp as punctuation.
    }();

  // Define regexps here so that the interpreter doesn't have to create an
  // object each time the function containing them is called.
  // The language spec requires a new object created even if you don't access
  // the $1 members.
  var pr_amp = /&/g;
  var pr_lt = /</g;
  var pr_gt = />/g;
  var pr_quot = /\"/g;
  /** like textToHtml but escapes double quotes to be attribute safe. */
  function attribToHtml(str) {
    return str.replace(pr_amp, '&amp;')
        .replace(pr_lt, '&lt;')
        .replace(pr_gt, '&gt;')
        .replace(pr_quot, '&quot;');
  }

  /** escapest html special characters to html. */
  function textToHtml(str) {
    return str.replace(pr_amp, '&amp;')
        .replace(pr_lt, '&lt;')
        .replace(pr_gt, '&gt;');
  }


  var pr_ltEnt = /&lt;/g;
  var pr_gtEnt = /&gt;/g;
  var pr_aposEnt = /&apos;/g;
  var pr_quotEnt = /&quot;/g;
  var pr_ampEnt = /&amp;/g;
  var pr_nbspEnt = /&nbsp;/g;
  /** unescapes html to plain text. */
  function htmlToText(html) {
    var pos = html.indexOf('&');
    if (pos < 0) { return html; }
    // Handle numeric entities specially.  We can't use functional substitution
    // since that doesn't work in older versions of Safari.
    // These should be rare since most browsers convert them to normal chars.
    for (--pos; (pos = html.indexOf('&#', pos + 1)) >= 0;) {
      var end = html.indexOf(';', pos);
      if (end >= 0) {
        var num = html.substring(pos + 3, end);
        var radix = 10;
        if (num && num.charAt(0) === 'x') {
          num = num.substring(1);
          radix = 16;
        }
        var codePoint = parseInt(num, radix);
        if (!isNaN(codePoint)) {
          html = (html.substring(0, pos) + String.fromCharCode(codePoint) +
                  html.substring(end + 1));
        }
      }
    }

    return html.replace(pr_ltEnt, '<')
        .replace(pr_gtEnt, '>')
        .replace(pr_aposEnt, "'")
        .replace(pr_quotEnt, '"')
        .replace(pr_nbspEnt, ' ')
        .replace(pr_ampEnt, '&');
  }

  /** is the given node's innerHTML normally unescaped? */
  function isRawContent(node) {
    return 'XMP' === node.tagName;
  }

  var newlineRe = /[\r\n]/g;
  /**
   * Are newlines and adjacent spaces significant in the given node's innerHTML?
   */
  function isPreformatted(node, content) {
    // PRE means preformatted, and is a very common case, so don't create
    // unnecessary computed style objects.
    if ('PRE' === node.tagName) { return true; }
    if (!newlineRe.test(content)) { return true; }  // Don't care
    var whitespace = '';
    // For disconnected nodes, IE has no currentStyle.
    if (node.currentStyle) {
      whitespace = node.currentStyle.whiteSpace;
    } else if (window.getComputedStyle) {
      // Firefox makes a best guess if node is disconnected whereas Safari
      // returns the empty string.
      whitespace = window.getComputedStyle(node, null).whiteSpace;
    }
    return !whitespace || whitespace === 'pre';
  }

  function normalizedHtml(node, out, opt_sortAttrs) {
    switch (node.nodeType) {
      case 1:  // an element
        var name = node.tagName.toLowerCase();

        out.push('<', name);
        var attrs = node.attributes;
        var n = attrs.length;
        if (n) {
          if (opt_sortAttrs) {
            var sortedAttrs = [];
            for (var i = n; --i >= 0;) { sortedAttrs[i] = attrs[i]; }
            sortedAttrs.sort(function (a, b) {
                return (a.name < b.name) ? -1 : a.name === b.name ? 0 : 1;
              });
            attrs = sortedAttrs;
          }
          for (var i = 0; i < n; ++i) {
            var attr = attrs[i];
            if (!attr.specified) { continue; }
            out.push(' ', attr.name.toLowerCase(),
                     '="', attribToHtml(attr.value), '"');
          }
        }
        out.push('>');
        for (var child = node.firstChild; child; child = child.nextSibling) {
          normalizedHtml(child, out, opt_sortAttrs);
        }
        if (node.firstChild || !/^(?:br|link|img)$/.test(name)) {
          out.push('<\/', name, '>');
        }
        break;
      case 3: case 4: // text
        out.push(textToHtml(node.nodeValue));
        break;
    }
  }

  /**
   * Given a group of {@link RegExp}s, returns a {@code RegExp} that globally
   * matches the union o the sets o strings matched d by the input RegExp.
   * Since it matches globally, if the input strings have a start-of-input
   * anchor (/^.../), it is ignored for the purposes of unioning.
   * @param {Array.<RegExp>} regexs non multiline, non-global regexs.
   * @return {RegExp} a global regex.
   */
  function combinePrefixPatterns(regexs) {
    var capturedGroupIndex = 0;

    var needToFoldCase = false;
    var ignoreCase = false;
    for (var i = 0, n = regexs.length; i < n; ++i) {
      var regex = regexs[i];
      if (regex.ignoreCase) {
        ignoreCase = true;
      } else if (/[a-z]/i.test(regex.source.replace(
                     /\\u[0-9a-f]{4}|\\x[0-9a-f]{2}|\\[^ux]/gi, ''))) {
        needToFoldCase = true;
        ignoreCase = false;
        break;
      }
    }

    function decodeEscape(charsetPart) {
      if (charsetPart.charAt(0) !== '\\') { return charsetPart.charCodeAt(0); }
      switch (charsetPart.charAt(1)) {
        case 'b': return 8;
        case 't': return 9;
        case 'n': return 0xa;
        case 'v': return 0xb;
        case 'f': return 0xc;
        case 'r': return 0xd;
        case 'u': case 'x':
          return parseInt(charsetPart.substring(2), 16)
              || charsetPart.charCodeAt(1);
        case '0': case '1': case '2': case '3': case '4':
        case '5': case '6': case '7':
          return parseInt(charsetPart.substring(1), 8);
        default: return charsetPart.charCodeAt(1);
      }
    }

    function encodeEscape(charCode) {
      if (charCode < 0x20) {
        return (charCode < 0x10 ? '\\x0' : '\\x') + charCode.toString(16);
      }
      var ch = String.fromCharCode(charCode);
      if (ch === '\\' || ch === '-' || ch === '[' || ch === ']') {
        ch = '\\' + ch;
      }
      return ch;
    }

    function caseFoldCharset(charSet) {
      var charsetParts = charSet.substring(1, charSet.length - 1).match(
          new RegExp(
              '\\\\u[0-9A-Fa-f]{4}'
              + '|\\\\x[0-9A-Fa-f]{2}'
              + '|\\\\[0-3][0-7]{0,2}'
              + '|\\\\[0-7]{1,2}'
              + '|\\\\[\\s\\S]'
              + '|-'
              + '|[^-\\\\]',
              'g'));
      var groups = [];
      var ranges = [];
      var inverse = charsetParts[0] === '^';
      for (var i = inverse ? 1 : 0, n = charsetParts.length; i < n; ++i) {
        var p = charsetParts[i];
        switch (p) {
          case '\\B': case '\\b':
          case '\\D': case '\\d':
          case '\\S': case '\\s':
          case '\\W': case '\\w':
            groups.push(p);
            continue;
        }
        var start = decodeEscape(p);
        var end;
        if (i + 2 < n && '-' === charsetParts[i + 1]) {
          end = decodeEscape(charsetParts[i + 2]);
          i += 2;
        } else {
          end = start;
        }
        ranges.push([start, end]);
        // If the range might intersect letters, then expand it.
        if (!(end < 65 || start > 122)) {
          if (!(end < 65 || start > 90)) {
            ranges.push([Math.max(65, start) | 32, Math.min(end, 90) | 32]);
          }
          if (!(end < 97 || start > 122)) {
            ranges.push([Math.max(97, start) & ~32, Math.min(end, 122) & ~32]);
          }
        }
      }

      // [[1, 10], [3, 4], [8, 12], [14, 14], [16, 16], [17, 17]]
      // -> [[1, 12], [14, 14], [16, 17]]
      ranges.sort(function (a, b) { return (a[0] - b[0]) || (b[1]  - a[1]); });
      var consolidatedRanges = [];
      var lastRange = [NaN, NaN];
      for (var i = 0; i < ranges.length; ++i) {
        var range = ranges[i];
        if (range[0] <= lastRange[1] + 1) {
          lastRange[1] = Math.max(lastRange[1], range[1]);
        } else {
          consolidatedRanges.push(lastRange = range);
        }
      }

      var out = ['['];
      if (inverse) { out.push('^'); }
      out.push.apply(out, groups);
      for (var i = 0; i < consolidatedRanges.length; ++i) {
        var range = consolidatedRanges[i];
        out.push(encodeEscape(range[0]));
        if (range[1] > range[0]) {
          if (range[1] + 1 > range[0]) { out.push('-'); }
          out.push(encodeEscape(range[1]));
        }
      }
      out.push(']');
      return out.join('');
    }

    function allowAnywhereFoldCaseAndRenumberGroups(regex) {
      // Split into character sets, escape sequences, punctuation strings
      // like ('(', '(?:', ')', '^'), and runs of characters that do not
      // include any of the above.
      var parts = regex.source.match(
          new RegExp(
              '(?:'
              + '\\[(?:[^\\x5C\\x5D]|\\\\[\\s\\S])*\\]'  // a character set
              + '|\\\\u[A-Fa-f0-9]{4}'  // a unicode escape
              + '|\\\\x[A-Fa-f0-9]{2}'  // a hex escape
              + '|\\\\[0-9]+'  // a back-reference or octal escape
              + '|\\\\[^ux0-9]'  // other escape sequence
              + '|\\(\\?[:!=]'  // start of a non-capturing group
              + '|[\\(\\)\\^]'  // start/emd of a group, or line start
              + '|[^\\x5B\\x5C\\(\\)\\^]+'  // run of other characters
              + ')',
              'g'));
      var n = parts.length;

      // Maps captured group numbers to the number they will occupy in
      // the output or to -1 if that has not been determined, or to
      // undefined if they need not be capturing in the output.
      var capturedGroups = [];

      // Walk over and identify back references to build the capturedGroups
      // mapping.
      for (var i = 0, groupIndex = 0; i < n; ++i) {
        var p = parts[i];
        if (p === '(') {
          // groups are 1-indexed, so max group index is count of '('
          ++groupIndex;
        } else if ('\\' === p.charAt(0)) {
          var decimalValue = +p.substring(1);
          if (decimalValue && decimalValue <= groupIndex) {
            capturedGroups[decimalValue] = -1;
          }
        }
      }

      // Renumber groups and reduce capturing groups to non-capturing groups
      // where possible.
      for (var i = 1; i < capturedGroups.length; ++i) {
        if (-1 === capturedGroups[i]) {
          capturedGroups[i] = ++capturedGroupIndex;
        }
      }
      for (var i = 0, groupIndex = 0; i < n; ++i) {
        var p = parts[i];
        if (p === '(') {
          ++groupIndex;
          if (capturedGroups[groupIndex] === undefined) {
            parts[i] = '(?:';
          }
        } else if ('\\' === p.charAt(0)) {
          var decimalValue = +p.substring(1);
          if (decimalValue && decimalValue <= groupIndex) {
            parts[i] = '\\' + capturedGroups[groupIndex];
          }
        }
      }

      // Remove any prefix anchors so that the output will match anywhere.
      // ^^ really does mean an anchored match though.
      for (var i = 0, groupIndex = 0; i < n; ++i) {
        if ('^' === parts[i] && '^' !== parts[i + 1]) { parts[i] = ''; }
      }

      // Expand letters to groupts to handle mixing of case-sensitive and
      // case-insensitive patterns if necessary.
      if (regex.ignoreCase && needToFoldCase) {
        for (var i = 0; i < n; ++i) {
          var p = parts[i];
          var ch0 = p.charAt(0);
          if (p.length >= 2 && ch0 === '[') {
            parts[i] = caseFoldCharset(p);
          } else if (ch0 !== '\\') {
            // TODO: handle letters in numeric escapes.
            parts[i] = p.replace(
                /[a-zA-Z]/g,
                function (ch) {
                  var cc = ch.charCodeAt(0);
                  return '[' + String.fromCharCode(cc & ~32, cc | 32) + ']';
                });
          }
        }
      }

      return parts.join('');
    }

    var rewritten = [];
    for (var i = 0, n = regexs.length; i < n; ++i) {
      var regex = regexs[i];
      if (regex.global || regex.multiline) { throw new Error('' + regex); }
      rewritten.push(
          '(?:' + allowAnywhereFoldCaseAndRenumberGroups(regex) + ')');
    }

    return new RegExp(rewritten.join('|'), ignoreCase ? 'gi' : 'g');
  }

  var PR_innerHtmlWorks = null;
  function getInnerHtml(node) {
    // inner html is hopelessly broken in Safari 2.0.4 when the content is
    // an html description of well formed XML and the containing tag is a PRE
    // tag, so we detect that case and emulate innerHTML.
    if (null === PR_innerHtmlWorks) {
      var testNode = document.createElement('PRE');
      testNode.appendChild(
          document.createTextNode('<!DOCTYPE foo PUBLIC "foo bar">\n<foo />'));
      PR_innerHtmlWorks = !/</.test(testNode.innerHTML);
    }

    if (PR_innerHtmlWorks) {
      var content = node.innerHTML;
      // XMP tags contain unescaped entities so require special handling.
      if (isRawContent(node)) {
        content = textToHtml(content);
      } else if (!isPreformatted(node, content)) {
        content = content.replace(/(<br\s*\/?>)[\r\n]+/g, '$1')
            .replace(/(?:[\r\n]+[ \t]*)+/g, ' ');
      }
      return content;
    }

    var out = [];
    for (var child = node.firstChild; child; child = child.nextSibling) {
      normalizedHtml(child, out);
    }
    return out.join('');
  }

  /** returns a function that expand tabs to spaces.  This function can be fed
    * successive chunks of text, and will maintain its own internal state to
    * keep track of how tabs are expanded.
    * @return {function (string) : string} a function that takes
    *   plain text and return the text with tabs expanded.
    * @private
    */
  function makeTabExpander(tabWidth) {
    var SPACES = '                ';
    var charInLine = 0;

    return function (plainText) {
      // walk over each character looking for tabs and newlines.
      // On tabs, expand them.  On newlines, reset charInLine.
      // Otherwise increment charInLine
      var out = null;
      var pos = 0;
      for (var i = 0, n = plainText.length; i < n; ++i) {
        var ch = plainText.charAt(i);

        switch (ch) {
          case '\t':
            if (!out) { out = []; }
            out.push(plainText.substring(pos, i));
            // calculate how much space we need in front of this part
            // nSpaces is the amount of padding -- the number of spaces needed
            // to move us to the next column, where columns occur at factors of
            // tabWidth.
            var nSpaces = tabWidth - (charInLine % tabWidth);
            charInLine += nSpaces;
            for (; nSpaces >= 0; nSpaces -= SPACES.length) {
              out.push(SPACES.substring(0, nSpaces));
            }
            pos = i + 1;
            break;
          case '\n':
            charInLine = 0;
            break;
          default:
            ++charInLine;
        }
      }
      if (!out) { return plainText; }
      out.push(plainText.substring(pos));
      return out.join('');
    };
  }

  var pr_chunkPattern = new RegExp(
      '[^<]+'  // A run of characters other than '<'
      + '|<\!--[\\s\\S]*?--\>'  // an HTML comment
      + '|<!\\[CDATA\\[[\\s\\S]*?\\]\\]>'  // a CDATA section
      // a probable tag that should not be highlighted
      + '|<\/?[a-zA-Z](?:[^>\"\']|\'[^\']*\'|\"[^\"]*\")*>'
      + '|<',  // A '<' that does not begin a larger chunk
      'g');
  var pr_commentPrefix = /^<\!--/;
  var pr_cdataPrefix = /^<!\[CDATA\[/;
  var pr_brPrefix = /^<br\b/i;
  var pr_tagNameRe = /^<(\/?)([a-zA-Z][a-zA-Z0-9]*)/;

  /** split markup into chunks of html tags (style null) and
    * plain text (style {@link #PR_PLAIN}), converting tags which are
    * significant for tokenization (<br>) into their textual equivalent.
    *
    * @param {string} s html where whitespace is considered significant.
    * @return {Object} source code and extracted tags.
    * @private
    */
  function extractTags(s) {
    // since the pattern has the 'g' modifier and defines no capturing groups,
    // this will return a list of all chunks which we then classify and wrap as
    // PR_Tokens
    var matches = s.match(pr_chunkPattern);
    var sourceBuf = [];
    var sourceBufLen = 0;
    var extractedTags = [];
    if (matches) {
      for (var i = 0, n = matches.length; i < n; ++i) {
        var match = matches[i];
        if (match.length > 1 && match.charAt(0) === '<') {
          if (pr_commentPrefix.test(match)) { continue; }
          if (pr_cdataPrefix.test(match)) {
            // strip CDATA prefix and suffix.  Don't unescape since it's CDATA
            sourceBuf.push(match.substring(9, match.length - 3));
            sourceBufLen += match.length - 12;
          } else if (pr_brPrefix.test(match)) {
            // <br> tags are lexically significant so convert them to text.
            // This is undone later.
            sourceBuf.push('\n');
            ++sourceBufLen;
          } else {
            if (match.indexOf(PR_NOCODE) >= 0 && isNoCodeTag(match)) {
              // A <span class="nocode"> will start a section that should be
              // ignored.  Continue walking the list until we see a matching end
              // tag.
              var name = match.match(pr_tagNameRe)[2];
              var depth = 1;
              var j;
              end_tag_loop:
              for (j = i + 1; j < n; ++j) {
                var name2 = matches[j].match(pr_tagNameRe);
                if (name2 && name2[2] === name) {
                  if (name2[1] === '/') {
                    if (--depth === 0) { break end_tag_loop; }
                  } else {
                    ++depth;
                  }
                }
              }
              if (j < n) {
                extractedTags.push(
                    sourceBufLen, matches.slice(i, j + 1).join(''));
                i = j;
              } else {  // Ignore unclosed sections.
                extractedTags.push(sourceBufLen, match);
              }
            } else {
              extractedTags.push(sourceBufLen, match);
            }
          }
        } else {
          var literalText = htmlToText(match);
          sourceBuf.push(literalText);
          sourceBufLen += literalText.length;
        }
      }
    }
    return { source: sourceBuf.join(''), tags: extractedTags };
  }

  /** True if the given tag contains a class attribute with the nocode class. */
  function isNoCodeTag(tag) {
    return !!tag
        // First canonicalize the representation of attributes
        .replace(/\s(\w+)\s*=\s*(?:\"([^\"]*)\"|'([^\']*)'|(\S+))/g,
                 ' $1="$2$3$4"')
        // Then look for the attribute we want.
        .match(/[cC][lL][aA][sS][sS]=\"[^\"]*\bnocode\b/);
  }

  /**
   * Apply the given language handler to sourceCode and add the resulting
   * decorations to out.
   * @param {number} basePos the index of sourceCode within the chunk of source
   *    whose decorations are already present on out.
   */
  function appendDecorations(basePos, sourceCode, langHandler, out) {
    if (!sourceCode) { return; }
    var job = {
      source: sourceCode,
      basePos: basePos
    };
    langHandler(job);
    out.push.apply(out, job.decorations);
  }

  /** Given triples of [style, pattern, context] returns a lexing function,
    * The lexing function interprets the patterns to find token boundaries and
    * returns a decoration list of the form
    * [index_0, style_0, index_1, style_1, ..., index_n, style_n]
    * where index_n is an index into the sourceCode, and style_n is a style
    * constant like PR_PLAIN.  index_n-1 <= index_n, and style_n-1 applies to
    * all characters in sourceCode[index_n-1:index_n].
    *
    * The stylePatterns is a list whose elements have the form
    * [style : string, pattern : RegExp, DEPRECATED, shortcut : string].
    *
    * Style is a style constant like PR_PLAIN, or can be a string of the
    * form 'lang-FOO', where FOO is a language extension describing the
    * language of the portion of the token in $1 after pattern executes.
    * E.g., if style is 'lang-lisp', and group 1 contains the text
    * '(hello (world))', then that portion of the token will be passed to the
    * registered lisp handler for formatting.
    * The text before and after group 1 will be restyled using this decorator
    * so decorators should take care that this doesn't result in infinite
    * recursion.  For example, the HTML lexer rule for SCRIPT elements looks
    * something like ['lang-js', /<[s]cript>(.+?)<\/script>/].  This may match
    * '<script>foo()<\/script>', which would cause the current decorator to
    * be called with '<script>' which would not match the same rule since
    * group 1 must not be empty, so it would be instead styled as PR_TAG by
    * the generic tag rule.  The handler registered for the 'js' extension would
    * then be called with 'foo()', and finally, the current decorator would
    * be called with '<\/script>' which would not match the original rule and
    * so the generic tag rule would identify it as a tag.
    *
    * Pattern must only match prefixes, and if it matches a prefix, then that
    * match is considered a token with the same style.
    *
    * Context is applied to the last non-whitespace, non-comment token
    * recognized.
    *
    * Shortcut is an optional string of characters, any of which, if the first
    * character, gurantee that this pattern and only this pattern matches.
    *
    * @param {Array} shortcutStylePatterns patterns that always start with
    *   a known character.  Must have a shortcut string.
    * @param {Array} fallthroughStylePatterns patterns that will be tried in
    *   order if the shortcut ones fail.  May have shortcuts.
    *
    * @return {function (Object)} a
    *   function that takes source code and returns a list of decorations.
    */
  function createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns) {
    var shortcuts = {};
    var tokenizer;
    (function () {
      var allPatterns = shortcutStylePatterns.concat(fallthroughStylePatterns);
      var allRegexs = [];
      var regexKeys = {};
      for (var i = 0, n = allPatterns.length; i < n; ++i) {
        var patternParts = allPatterns[i];
        var shortcutChars = patternParts[3];
        if (shortcutChars) {
          for (var c = shortcutChars.length; --c >= 0;) {
            shortcuts[shortcutChars.charAt(c)] = patternParts;
          }
        }
        var regex = patternParts[1];
        var k = '' + regex;
        if (!regexKeys.hasOwnProperty(k)) {
          allRegexs.push(regex);
          regexKeys[k] = null;
        }
      }
      allRegexs.push(/[\0-\uffff]/);
      tokenizer = combinePrefixPatterns(allRegexs);
    })();

    var nPatterns = fallthroughStylePatterns.length;
    var notWs = /\S/;

    /**
     * Lexes job.source and produces an output array job.decorations of style
     * classes preceded by the position at which they start in job.source in
     * order.
     *
     * @param {Object} job an object like {@code
     *    source: {string} sourceText plain text,
     *    basePos: {int} position of job.source in the larger chunk of
     *        sourceCode.
     * }
     */
    var decorate = function (job) {
      var sourceCode = job.source, basePos = job.basePos;
      /** Even entries are positions in source in ascending order.  Odd enties
        * are style markers (e.g., PR_COMMENT) that run from that position until
        * the end.
        * @type {Array.<number|string>}
        */
      var decorations = [basePos, PR_PLAIN];
      var pos = 0;  // index into sourceCode
      var tokens = sourceCode.match(tokenizer) || [];
      var styleCache = {};

      for (var ti = 0, nTokens = tokens.length; ti < nTokens; ++ti) {
        var token = tokens[ti];
        var style = styleCache[token];
        var match = void 0;

        var isEmbedded;
        if (typeof style === 'string') {
          isEmbedded = false;
        } else {
          var patternParts = shortcuts[token.charAt(0)];
          if (patternParts) {
            match = token.match(patternParts[1]);
            style = patternParts[0];
          } else {
            for (var i = 0; i < nPatterns; ++i) {
              patternParts = fallthroughStylePatterns[i];
              match = token.match(patternParts[1]);
              if (match) {
                style = patternParts[0];
                break;
              }
            }

            if (!match) {  // make sure that we make progress
              style = PR_PLAIN;
            }
          }

          isEmbedded = style.length >= 5 && 'lang-' === style.substring(0, 5);
          if (isEmbedded && !(match && typeof match[1] === 'string')) {
            isEmbedded = false;
            style = PR_SOURCE;
          }

          if (!isEmbedded) { styleCache[token] = style; }
        }

        var tokenStart = pos;
        pos += token.length;

        if (!isEmbedded) {
          decorations.push(basePos + tokenStart, style);
        } else {  // Treat group 1 as an embedded block of source code.
          var embeddedSource = match[1];
          var embeddedSourceStart = token.indexOf(embeddedSource);
          var embeddedSourceEnd = embeddedSourceStart + embeddedSource.length;
          if (match[2]) {
            // If embeddedSource can be blank, then it would match at the
            // beginning which would cause us to infinitely recurse on the
            // entire token, so we catch the right context in match[2].
            embeddedSourceEnd = token.length - match[2].length;
            embeddedSourceStart = embeddedSourceEnd - embeddedSource.length;
          }
          var lang = style.substring(5);
          // Decorate the left of the embedded source
          appendDecorations(
              basePos + tokenStart,
              token.substring(0, embeddedSourceStart),
              decorate, decorations);
          // Decorate the embedded source
          appendDecorations(
              basePos + tokenStart + embeddedSourceStart,
              embeddedSource,
              langHandlerForExtension(lang, embeddedSource),
              decorations);
          // Decorate the right of the embedded section
          appendDecorations(
              basePos + tokenStart + embeddedSourceEnd,
              token.substring(embeddedSourceEnd),
              decorate, decorations);
        }
      }
      job.decorations = decorations;
    };
    return decorate;
  }

  /** returns a function that produces a list of decorations from source text.
    *
    * This code treats ", ', and ` as string delimiters, and \ as a string
    * escape.  It does not recognize perl's qq() style strings.
    * It has no special handling for double delimiter escapes as in basic, or
    * the tripled delimiters used in python, but should work on those regardless
    * although in those cases a single string literal may be broken up into
    * multiple adjacent string literals.
    *
    * It recognizes C, C++, and shell style comments.
    *
    * @param {Object} options a set of optional parameters.
    * @return {function (Object)} a function that examines the source code
    *     in the input job and builds the decoration list.
    */
  function sourceDecorator(options) {
    var shortcutStylePatterns = [], fallthroughStylePatterns = [];
    if (options['tripleQuotedStrings']) {
      // '''multi-line-string''', 'single-line-string', and double-quoted
      shortcutStylePatterns.push(
          [PR_STRING,  /^(?:\'\'\'(?:[^\'\\]|\\[\s\S]|\'{1,2}(?=[^\']))*(?:\'\'\'|$)|\"\"\"(?:[^\"\\]|\\[\s\S]|\"{1,2}(?=[^\"]))*(?:\"\"\"|$)|\'(?:[^\\\']|\\[\s\S])*(?:\'|$)|\"(?:[^\\\"]|\\[\s\S])*(?:\"|$))/,
           null, '\'"']);
    } else if (options['multiLineStrings']) {
      // 'multi-line-string', "multi-line-string"
      shortcutStylePatterns.push(
          [PR_STRING,  /^(?:\'(?:[^\\\']|\\[\s\S])*(?:\'|$)|\"(?:[^\\\"]|\\[\s\S])*(?:\"|$)|\`(?:[^\\\`]|\\[\s\S])*(?:\`|$))/,
           null, '\'"`']);
    } else {
      // 'single-line-string', "single-line-string"
      shortcutStylePatterns.push(
          [PR_STRING,
           /^(?:\'(?:[^\\\'\r\n]|\\.)*(?:\'|$)|\"(?:[^\\\"\r\n]|\\.)*(?:\"|$))/,
           null, '"\'']);
    }
    if (options['verbatimStrings']) {
      // verbatim-string-literal production from the C# grammar.  See issue 93.
      fallthroughStylePatterns.push(
          [PR_STRING, /^@\"(?:[^\"]|\"\")*(?:\"|$)/, null]);
    }
    if (options['hashComments']) {
      if (options['cStyleComments']) {
        // Stop C preprocessor declarations at an unclosed open comment
        shortcutStylePatterns.push(
            [PR_COMMENT, /^#(?:(?:define|elif|else|endif|error|ifdef|include|ifndef|line|pragma|undef|warning)\b|[^\r\n]*)/,
             null, '#']);
        fallthroughStylePatterns.push(
            [PR_STRING,
             /^<(?:(?:(?:\.\.\/)*|\/?)(?:[\w-]+(?:\/[\w-]+)+)?[\w-]+\.h|[a-z]\w*)>/,
             null]);
      } else {
        shortcutStylePatterns.push([PR_COMMENT, /^#[^\r\n]*/, null, '#']);
      }
    }
    if (options['cStyleComments']) {
      fallthroughStylePatterns.push([PR_COMMENT, /^\/\/[^\r\n]*/, null]);
      fallthroughStylePatterns.push(
          [PR_COMMENT, /^\/\*[\s\S]*?(?:\*\/|$)/, null]);
    }
    if (options['regexLiterals']) {
      var REGEX_LITERAL = (
          // A regular expression literal starts with a slash that is
          // not followed by * or / so that it is not confused with
          // comments.
          '/(?=[^/*])'
          // and then contains any number of raw characters,
          + '(?:[^/\\x5B\\x5C]'
          // escape sequences (\x5C),
          +    '|\\x5C[\\s\\S]'
          // or non-nesting character sets (\x5B\x5D);
          +    '|\\x5B(?:[^\\x5C\\x5D]|\\x5C[\\s\\S])*(?:\\x5D|$))+'
          // finally closed by a /.
          + '/');
      fallthroughStylePatterns.push(
          ['lang-regex',
           new RegExp('^' + REGEXP_PRECEDER_PATTERN + '(' + REGEX_LITERAL + ')')
           ]);
    }

    var keywords = options['keywords'].replace(/^\s+|\s+$/g, '');
    if (keywords.length) {
      fallthroughStylePatterns.push(
          [PR_KEYWORD,
           new RegExp('^(?:' + keywords.replace(/\s+/g, '|') + ')\\b'), null]);
    }

    shortcutStylePatterns.push([PR_PLAIN,       /^\s+/, null, ' \r\n\t\xA0']);
    fallthroughStylePatterns.push(
        // TODO(mikesamuel): recognize non-latin letters and numerals in idents
        [PR_LITERAL,     /^@[a-z_$][a-z_$@0-9]*/i, null],
        [PR_TYPE,        /^@?[A-Z]+[a-z][A-Za-z_$@0-9]*/, null],
        [PR_PLAIN,       /^[a-z_$][a-z_$@0-9]*/i, null],
        [PR_LITERAL,
         new RegExp(
             '^(?:'
             // A hex number
             + '0x[a-f0-9]+'
             // or an octal or decimal number,
             + '|(?:\\d(?:_\\d+)*\\d*(?:\\.\\d*)?|\\.\\d\\+)'
             // possibly in scientific notation
             + '(?:e[+\\-]?\\d+)?'
             + ')'
             // with an optional modifier like UL for unsigned long
             + '[a-z]*', 'i'),
         null, '0123456789'],
        [PR_PUNCTUATION, /^.[^\s\w\.$@\'\"\`\/\#]*/, null]);

    return createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns);
  }

  var decorateSource = sourceDecorator({
        'keywords': ALL_KEYWORDS,
        'hashComments': true,
        'cStyleComments': true,
        'multiLineStrings': true,
        'regexLiterals': true
      });

  /** Breaks {@code job.source} around style boundaries in
    * {@code job.decorations} while re-interleaving {@code job.extractedTags},
    * and leaves the result in {@code job.prettyPrintedHtml}.
    * @param {Object} job like {
    *    source: {string} source as plain text,
    *    extractedTags: {Array.<number|string>} extractedTags chunks of raw
    *                   html preceded by their position in {@code job.source}
    *                   in order
    *    decorations: {Array.<number|string} an array of style classes preceded
    *                 by the position at which they start in job.source in order
    * }
    * @private
    */
  function recombineTagsAndDecorations(job) {
    var sourceText = job.source;
    var extractedTags = job.extractedTags;
    var decorations = job.decorations;

    var html = [];
    // index past the last char in sourceText written to html
    var outputIdx = 0;

    var openDecoration = null;
    var currentDecoration = null;
    var tagPos = 0;  // index into extractedTags
    var decPos = 0;  // index into decorations
    var tabExpander = makeTabExpander(window['PR_TAB_WIDTH']);

    var adjacentSpaceRe = /([\r\n ]) /g;
    var startOrSpaceRe = /(^| ) /gm;
    var newlineRe = /\r\n?|\n/g;
    var trailingSpaceRe = /[ \r\n]$/;
    var lastWasSpace = true;  // the last text chunk emitted ended with a space.

    // See bug 71 and http://stackoverflow.com/questions/136443/why-doesnt-ie7-
    var isIE678 = window['_pr_isIE6']();
    var lineBreakHtml = (
        isIE678
        ? (job.sourceNode.tagName === 'PRE'
           // Use line feeds instead of <br>s so that copying and pasting works
           // on IE.
           // Doing this on other browsers breaks lots of stuff since \r\n is
           // treated as two newlines on Firefox.
           ? (isIE678 === 6 ? '&#160;\r\n' :
              isIE678 === 7 ? '&#160;<br>\r' : '&#160;\r')
           // IE collapses multiple adjacent <br>s into 1 line break.
           // Prefix every newline with '&#160;' to prevent such behavior.
           // &nbsp; is the same as &#160; but works in XML as well as HTML.
           : '&#160;<br />')
        : '<br />');

    // Look for a class like linenums or linenums:<n> where <n> is the 1-indexed
    // number of the first line.
    var numberLines = job.sourceNode.className.match(/\blinenums\b(?::(\d+))?/);
    var lineBreaker;
    if (numberLines) {
      var lineBreaks = [];
      for (var i = 0; i < 10; ++i) {
        lineBreaks[i] = lineBreakHtml + '</li><li class="L' + i + '">';
      }
      var lineNum = numberLines[1] && numberLines[1].length 
          ? numberLines[1] - 1 : 0;  // Lines are 1-indexed
      html.push('<ol class="linenums"><li class="L', (lineNum) % 10, '"');
      if (lineNum) {
        html.push(' value="', lineNum + 1, '"');
      }
      html.push('>');
      lineBreaker = function () {
        var lb = lineBreaks[++lineNum % 10];
        // If a decoration is open, we need to close it before closing a list-item
        // and reopen it on the other side of the list item.
        return openDecoration
            ? ('</span>' + lb + '<span class="' + openDecoration + '">') : lb;
      };
    } else {
      lineBreaker = lineBreakHtml;
    }

    // A helper function that is responsible for opening sections of decoration
    // and outputing properly escaped chunks of source
    function emitTextUpTo(sourceIdx) {
      if (sourceIdx > outputIdx) {
        if (openDecoration && openDecoration !== currentDecoration) {
          // Close the current decoration
          html.push('</span>');
          openDecoration = null;
        }
        if (!openDecoration && currentDecoration) {
          openDecoration = currentDecoration;
          html.push('<span class="', openDecoration, '">');
        }
        // This interacts badly with some wikis which introduces paragraph tags
        // into pre blocks for some strange reason.
        // It's necessary for IE though which seems to lose the preformattedness
        // of <pre> tags when their innerHTML is assigned.
        // http://stud3.tuwien.ac.at/~e0226430/innerHtmlQuirk.html
        // and it serves to undo the conversion of <br>s to newlines done in
        // chunkify.
        var htmlChunk = textToHtml(
            tabExpander(sourceText.substring(outputIdx, sourceIdx)))
            .replace(lastWasSpace
                     ? startOrSpaceRe
                     : adjacentSpaceRe, '$1&#160;');
        // Keep track of whether we need to escape space at the beginning of the
        // next chunk.
        lastWasSpace = trailingSpaceRe.test(htmlChunk);
        html.push(htmlChunk.replace(newlineRe, lineBreaker));
        outputIdx = sourceIdx;
      }
    }

    while (true) {
      // Determine if we're going to consume a tag this time around.  Otherwise
      // we consume a decoration or exit.
      var outputTag;
      if (tagPos < extractedTags.length) {
        if (decPos < decorations.length) {
          // Pick one giving preference to extractedTags since we shouldn't open
          // a new style that we're going to have to immediately close in order
          // to output a tag.
          outputTag = extractedTags[tagPos] <= decorations[decPos];
        } else {
          outputTag = true;
        }
      } else {
        outputTag = false;
      }
      // Consume either a decoration or a tag or exit.
      if (outputTag) {
        emitTextUpTo(extractedTags[tagPos]);
        if (openDecoration) {
          // Close the current decoration
          html.push('</span>');
          openDecoration = null;
        }
        html.push(extractedTags[tagPos + 1]);
        tagPos += 2;
      } else if (decPos < decorations.length) {
        emitTextUpTo(decorations[decPos]);
        currentDecoration = decorations[decPos + 1];
        decPos += 2;
      } else {
        break;
      }
    }
    emitTextUpTo(sourceText.length);
    if (openDecoration) {
      html.push('</span>');
    }
    if (numberLines) { html.push('</li></ol>'); }
    job.prettyPrintedHtml = html.join('');
  }

  /** Maps language-specific file extensions to handlers. */
  var langHandlerRegistry = {};
  /** Register a language handler for the given file extensions.
    * @param {function (Object)} handler a function from source code to a list
    *      of decorations.  Takes a single argument job which describes the
    *      state of the computation.   The single parameter has the form
    *      {@code {
    *        source: {string} as plain text.
    *        decorations: {Array.<number|string>} an array of style classes
    *                     preceded by the position at which they start in
    *                     job.source in order.
    *                     The language handler should assigned this field.
    *        basePos: {int} the position of source in the larger source chunk.
    *                 All positions in the output decorations array are relative
    *                 to the larger source chunk.
    *      } }
    * @param {Array.<string>} fileExtensions
    */
  function registerLangHandler(handler, fileExtensions) {
    for (var i = fileExtensions.length; --i >= 0;) {
      var ext = fileExtensions[i];
      if (!langHandlerRegistry.hasOwnProperty(ext)) {
        langHandlerRegistry[ext] = handler;
      } else if ('console' in window) {
        console['warn']('cannot override language handler %s', ext);
      }
    }
  }
  function langHandlerForExtension(extension, source) {
    if (!(extension && langHandlerRegistry.hasOwnProperty(extension))) {
      // Treat it as markup if the first non whitespace character is a < and
      // the last non-whitespace character is a >.
      extension = /^\s*</.test(source)
          ? 'default-markup'
          : 'default-code';
    }
    return langHandlerRegistry[extension];
  }
  registerLangHandler(decorateSource, ['default-code']);
  registerLangHandler(
      createSimpleLexer(
          [],
          [
           [PR_PLAIN,       /^[^<?]+/],
           [PR_DECLARATION, /^<!\w[^>]*(?:>|$)/],
           [PR_COMMENT,     /^<\!--[\s\S]*?(?:-\->|$)/],
           // Unescaped content in an unknown language
           ['lang-',        /^<\?([\s\S]+?)(?:\?>|$)/],
           ['lang-',        /^<%([\s\S]+?)(?:%>|$)/],
           [PR_PUNCTUATION, /^(?:<[%?]|[%?]>)/],
           ['lang-',        /^<xmp\b[^>]*>([\s\S]+?)<\/xmp\b[^>]*>/i],
           // Unescaped content in javascript.  (Or possibly vbscript).
           ['lang-js',      /^<script\b[^>]*>([\s\S]*?)(<\/script\b[^>]*>)/i],
           // Contains unescaped stylesheet content
           ['lang-css',     /^<style\b[^>]*>([\s\S]*?)(<\/style\b[^>]*>)/i],
           ['lang-in.tag',  /^(<\/?[a-z][^<>]*>)/i]
          ]),
      ['default-markup', 'htm', 'html', 'mxml', 'xhtml', 'xml', 'xsl']);
  registerLangHandler(
      createSimpleLexer(
          [
           [PR_PLAIN,        /^[\s]+/, null, ' \t\r\n'],
           [PR_ATTRIB_VALUE, /^(?:\"[^\"]*\"?|\'[^\']*\'?)/, null, '\"\'']
           ],
          [
           [PR_TAG,          /^^<\/?[a-z](?:[\w.:-]*\w)?|\/?>$/i],
           [PR_ATTRIB_NAME,  /^(?!style[\s=]|on)[a-z](?:[\w:-]*\w)?/i],
           ['lang-uq.val',   /^=\s*([^>\'\"\s]*(?:[^>\'\"\s\/]|\/(?=\s)))/],
           [PR_PUNCTUATION,  /^[=<>\/]+/],
           ['lang-js',       /^on\w+\s*=\s*\"([^\"]+)\"/i],
           ['lang-js',       /^on\w+\s*=\s*\'([^\']+)\'/i],
           ['lang-js',       /^on\w+\s*=\s*([^\"\'>\s]+)/i],
           ['lang-css',      /^style\s*=\s*\"([^\"]+)\"/i],
           ['lang-css',      /^style\s*=\s*\'([^\']+)\'/i],
           ['lang-css',      /^style\s*=\s*([^\"\'>\s]+)/i]
           ]),
      ['in.tag']);
  registerLangHandler(
      createSimpleLexer([], [[PR_ATTRIB_VALUE, /^[\s\S]+/]]), ['uq.val']);
  registerLangHandler(sourceDecorator({
          'keywords': CPP_KEYWORDS,
          'hashComments': true,
          'cStyleComments': true
        }), ['c', 'cc', 'cpp', 'cxx', 'cyc', 'm']);
  registerLangHandler(sourceDecorator({
          'keywords': 'null true false'
        }), ['json']);
  registerLangHandler(sourceDecorator({
          'keywords': CSHARP_KEYWORDS,
          'hashComments': true,
          'cStyleComments': true,
          'verbatimStrings': true
        }), ['cs']);
  registerLangHandler(sourceDecorator({
          'keywords': JAVA_KEYWORDS,
          'cStyleComments': true
        }), ['java']);
  registerLangHandler(sourceDecorator({
          'keywords': SH_KEYWORDS,
          'hashComments': true,
          'multiLineStrings': true
        }), ['bsh', 'csh', 'sh']);
  registerLangHandler(sourceDecorator({
          'keywords': PYTHON_KEYWORDS,
          'hashComments': true,
          'multiLineStrings': true,
          'tripleQuotedStrings': true
        }), ['cv', 'py']);
  registerLangHandler(sourceDecorator({
          'keywords': PERL_KEYWORDS,
          'hashComments': true,
          'multiLineStrings': true,
          'regexLiterals': true
        }), ['perl', 'pl', 'pm']);
  registerLangHandler(sourceDecorator({
          'keywords': RUBY_KEYWORDS,
          'hashComments': true,
          'multiLineStrings': true,
          'regexLiterals': true
        }), ['rb']);
  registerLangHandler(sourceDecorator({
          'keywords': JSCRIPT_KEYWORDS,
          'cStyleComments': true,
          'regexLiterals': true
        }), ['js']);
  registerLangHandler(
      createSimpleLexer([], [[PR_STRING, /^[\s\S]+/]]), ['regex']);

  function applyDecorator(job) {
    var sourceCodeHtml = job.sourceCodeHtml;
    var opt_langExtension = job.langExtension;

    // Prepopulate output in case processing fails with an exception.
    job.prettyPrintedHtml = sourceCodeHtml;

    try {
      // Extract tags, and convert the source code to plain text.
      var sourceAndExtractedTags = extractTags(sourceCodeHtml);
      /** Plain text. @type {string} */
      var source = sourceAndExtractedTags.source;
      job.source = source;
      job.basePos = 0;

      /** Even entries are positions in source in ascending order.  Odd entries
        * are tags that were extracted at that position.
        * @type {Array.<number|string>}
        */
      job.extractedTags = sourceAndExtractedTags.tags;

      // Apply the appropriate language handler
      langHandlerForExtension(opt_langExtension, source)(job);
      // Integrate the decorations and tags back into the source code to produce
      // a decorated html string which is left in job.prettyPrintedHtml.
      recombineTagsAndDecorations(job);
    } catch (e) {
      if ('console' in window) {
        console['log'](e && e['stack'] ? e['stack'] : e);
      }
    }
  }

  function prettyPrintOne(sourceCodeHtml, opt_langExtension) {
    var job = {
      sourceCodeHtml: sourceCodeHtml,
      langExtension: opt_langExtension
    };
    applyDecorator(job);
    return job.prettyPrintedHtml;
  }

  function prettyPrint(opt_whenDone) {
    function byTagName(tn) { return document.getElementsByTagName(tn); }
    // fetch a list of nodes to rewrite
    var codeSegments = [byTagName('pre'), byTagName('code'), byTagName('xmp')];
    var elements = [];
    for (var i = 0; i < codeSegments.length; ++i) {
      for (var j = 0, n = codeSegments[i].length; j < n; ++j) {
        elements.push(codeSegments[i][j]);
      }
    }
    codeSegments = null;

    var clock = Date;
    if (!clock['now']) {
      clock = { 'now': function () { return (new Date).getTime(); } };
    }

    // The loop is broken into a series of continuations to make sure that we
    // don't make the browser unresponsive when rewriting a large page.
    var k = 0;
    var prettyPrintingJob;

    function doWork() {
      var endTime = (window['PR_SHOULD_USE_CONTINUATION'] ?
                     clock.now() + 250 /* ms */ :
                     Infinity);
      for (; k < elements.length && clock.now() < endTime; k++) {
        var cs = elements[k];
        if (cs.className && cs.className.indexOf('prettyprint') >= 0) {
          // If the classes includes a language extensions, use it.
          // Language extensions can be specified like
          //     <pre class="prettyprint lang-cpp">
          // the language extension "cpp" is used to find a language handler as
          // passed to PR_registerLangHandler.
          var langExtension = cs.className.match(/\blang-(\w+)\b/);
          if (langExtension) { langExtension = langExtension[1]; }

          // make sure this is not nested in an already prettified element
          var nested = false;
          for (var p = cs.parentNode; p; p = p.parentNode) {
            if ((p.tagName === 'pre' || p.tagName === 'code' ||
                 p.tagName === 'xmp') &&
                p.className && p.className.indexOf('prettyprint') >= 0) {
              nested = true;
              break;
            }
          }
          if (!nested) {
            // fetch the content as a snippet of properly escaped HTML.
            // Firefox adds newlines at the end.
            var content = getInnerHtml(cs);
            content = content.replace(/(?:\r\n?|\n)$/, '');

            // do the pretty printing
            prettyPrintingJob = {
              sourceCodeHtml: content,
              langExtension: langExtension,
              sourceNode: cs
            };
            applyDecorator(prettyPrintingJob);
            replaceWithPrettyPrintedHtml();
          }
        }
      }
      if (k < elements.length) {
        // finish up in a continuation
        setTimeout(doWork, 250);
      } else if (opt_whenDone) {
        opt_whenDone();
      }
    }

    function replaceWithPrettyPrintedHtml() {
      var newContent = prettyPrintingJob.prettyPrintedHtml;
      if (!newContent) { return; }
      var cs = prettyPrintingJob.sourceNode;

      // push the prettified html back into the tag.
      if (!isRawContent(cs)) {
        // just replace the old html with the new
        cs.innerHTML = newContent;
      } else {
        // we need to change the tag to a <pre> since <xmp>s do not allow
        // embedded tags such as the span tags used to attach styles to
        // sections of source code.
        var pre = document.createElement('PRE');
        for (var i = 0; i < cs.attributes.length; ++i) {
          var a = cs.attributes[i];
          if (a.specified) {
            var aname = a.name.toLowerCase();
            if (aname === 'class') {
              pre.className = a.value;  // For IE 6
            } else {
              pre.setAttribute(a.name, a.value);
            }
          }
        }
        pre.innerHTML = newContent;

        // remove the old
        cs.parentNode.replaceChild(pre, cs);
        cs = pre;
      }
    }

    doWork();
    content = document.getElementById('content');
    highlight(content, 'MUST NOT');
    highlight(content, 'SHALL NOT');
    highlight(content, 'MAY NOT');
    highlight(content, 'SHOULD NOT');
    highlight(content, 'MUST');
    highlight(content, 'SHALL');
    highlight(content, 'MAY');
    highlight(content, 'SHOULD');

  }

function highlight(container,what) {
    var content = container.innerHTML;
    pattern = new RegExp(what,'g');
    replaceWith = '<b>'+what+'</b>',
    container.innerHTML = content.replace(pattern,replaceWith);
}

  window['PR_normalizedHtml'] = normalizedHtml;
  window['prettyPrintOne'] = prettyPrintOne;
  window['prettyPrint'] = prettyPrint;
  window['PR'] = {
        'combinePrefixPatterns': combinePrefixPatterns,
        'createSimpleLexer': createSimpleLexer,
        'registerLangHandler': registerLangHandler,
        'sourceDecorator': sourceDecorator,
        'PR_ATTRIB_NAME': PR_ATTRIB_NAME,
        'PR_ATTRIB_VALUE': PR_ATTRIB_VALUE,
        'PR_COMMENT': PR_COMMENT,
        'PR_DECLARATION': PR_DECLARATION,
        'PR_KEYWORD': PR_KEYWORD,
        'PR_LITERAL': PR_LITERAL,
        'PR_NOCODE': PR_NOCODE,
        'PR_PLAIN': PR_PLAIN,
        'PR_PUNCTUATION': PR_PUNCTUATION,
        'PR_SOURCE': PR_SOURCE,
        'PR_STRING': PR_STRING,
        'PR_TAG': PR_TAG,
        'PR_TYPE': PR_TYPE
      };
})();

window.onload= function() { 
	prettyPrint();
};


</script>

</head>
<body id="content">

<div class="api">
     <a href="http://webinos.org"><img src="http://webinos.org/wp-content/uploads/2011/press_releases/webinos_thumb_150x48.png" alt="Webinos Logo"></a>

     <h1 class="head">Device APIs - Design Patterns and Guidelines </h1>
     <h3>April 2011</h3>
</div>
<hr> 
<h2>Abstract</h2> 
 
<div class="brief"> 
<p> 
This document describes the common patterns and design criteria that should be used to specify Webinos APIs. 
</p>
</div> 

<h2>Status</h2> 
 
<div class="brief"> 
<p> 
First draft for initial discussion. 
</p>
</div> 

<div class="toc">
<h2>Table of Contents</h2> 
<dl>
  <dt><span class="section"><a href="#introduction">1 - Introduction</a></span> </dt>
  <dt><span class="section"><a href="#webidlusage">2 - WebIDL Usage</a></span> </dt>
  <dt><span class="section"><a href="#asynchronousmethods">3 - Asynchronous Methods</a></span> </dt>
  <dt><span class="section"><a href="#errorhandling">4 - Error Handling</a></span> </dt>
  <dt><span class="section"><a href="#optionalnullable">5 - Optional, Nullable and valid arguments</a></span> </dt>
  <dt><span class="section"><a href="#accesingapis">6 - Accessing APIs and using API Features</a></span> </dt>
</dl>

<div class="section" lang="en">
<h2 class="title" style="clear: both;"><a name="introduction"></a>1 - Introduction</h2>
This document describes the common patterns and design criteria that are followed in the APIs defined by Webinos. Webinos APIs are specified through WebIDL together with text descriptions that define the behaviour of the API interfaces, methods and attributes.

Apart from the Webinos defined APIs, Webinos is going to refer to other APIs defined by other parties (e.g. W3C, WAC...). Webinos is not going to modify those APIs, so it is anticipated that some of them may not be aligned with the patterns defined in this document.

In most of the cases, this document does not prescribe a unique solution for the different API characteristics, but describes what are the feasible alternatives, what are the preferred one(s) and the situations in which different alternatives should be used.
</div>

<div class="section" lang="en">
<h2 class="title" style="clear: both;"><a name="webidlusage"></a>2 - WebIDL Usage</h2>
<p>
Webinos Device APIs are defined through WebIDL. In particular, the version of WebIDL specification used in Webinos is the W3C 1st June 2011 Editor's Draft . W3C WebIDL specification defines interface definition language, Web IDL. Web IDL is an IDL variant with a number of features that allow the behavior of ECMAScript objects to be specified more readily. The specification details how interfaces described with Web IDL correspond to constructs within ECMAScript.
</p>
<p>
The JavaScript APIs available to developers, will be the ECMAScript binding of the WebIDL code detailed in Webinos APIs specification. Additionally to the WebIDL definitions, the Webinos APIs provide additional information that further describe in prose the functionality of the methods formally defined in WebIDL (e.g. what are the potential error cases, what are the valid arguments expected by the implementation...).
</p>
</div>


<div class="section" lang="en">
<h2 class="title" style="clear: both;"><a name="asynchronousmethods"></a>3 - Asynchronous Methods </h2>
<p>
ECMAScript methods can be either synchronous or asynchronous. Methods using the synchronous mode of operation do not return control to the caller until the operation is complete. Asynchronous methods return immediately and notify the caller at some point in the future of the results via callback method(s). The callback(s) are specified as input parameters to the asynchronous method. Methods that may take a long time to be executed or that may be subject to security prompt should be defined as asynchronous methods in Webinos APIs.
</p>
<p>
There are different approaches to define asynchronous methods:
<ul>
<li> Passing arguments that are functions that handle the callbacks.</li>
<li> Passing a full interface as input argument.</li>
<li> Using events instead of methods to perform asynchronous operations.</li>
</ul>
</p>
<div class="section" lang="en">
<h3 class="title" style="clear: both;"><a name="functiononly"></a>3.1 - Function Only Success Callbacks</h3>
<p>
This is used by many specifications (e.g. WAC APIs, W3C Geolocation...). In this case, the first two input arguments for the asynchronous methods are:
<ul>
<li>The first argument is a Function object that specifies the callback to be invoked in case of success (e.g. SuccessCallback).</li>
<li>The second argument is a Function object instantiating the ErrorCallback interface.</li>
</ul>
</p>
<p>
Only one of the callbacks is invoked and it is invoked only once.
</p>
<p>
The following WebIDL excerpt specifies how this approach can be specified.
</p>
<div id="container"><div><span class="signatureBlockTitle"><b>Function Only Success Callback WebIDL</b></span><pre class="webidl prettyprint">
PendingOperation fooOperation(in SuccessCallback successCallback, 
                              in ErrorCallback? errorCallback, 
                              in Options options);

[Callback=FunctionOnly, NoInterfaceObject] interface SuccessCallback {
   void onsuccess();
};

[Callback=FunctionOnly, NoInterfaceObject] interface ErrorCallback {
   void onerror(in Error error);
};
</div>

<p>Which could be used by developers as follows:</p>

<div id="container"><div><span class="signatureBlockTitle"><b>Function Only Success Callback Usage</b></span>
<pre class="examplecode prettyprint">
fooOperation(handleSuccess(){alert("Operation Completed Successfully");},
             handleError(e){alert("Operation Failed: " + e.message );},
             {option1:0, option1:1000});
</pre>

<p> This is the <b>preferred way to specify asynchronous operations in Webinos APIs</b> as it is a well-known and simple mechanism.</p>
<p> It is recommended that Webinos APIs specify that the second input argument (the errorCallback) is always optional and nullable, so that when it is not included or it is null or undefined, the implementation is just silent about any error that occurs during the asynchronous phase of the operation. NOTE: In some cases the "optional" tag could not be prefixed in the WebIDL definition because otherwise all the subsequents attributes should have been also optional which may not be possible in all the cases. However, in those cases the optionality of the errorCallback could be documented in the method description and by declaring the argument as nullable by suffixing the '?' character to the argument data type.</p>
<p>
It is also recommended for Webinos APIs that the first input parameter is mandatory, and if it does not contain a valid value (e.g. it is null or undefined or does not contain a function), the ErrorCallback will be launched (provided a valid errorCallback has been passed).
</p>

<p>For example, the following WebIDL definition states that the errorCallback and options arguments are optional and nullable:</p>

<div id="container"><div><span class="signatureBlockTitle"><b>Function Only Success Callback - Optional ErrorCallback</b></span><pre class="webidl prettyprint">
void fooOperation(in SuccessCallback successCallback, 
                              in optional ErrorCallback? errorCallback, 
                              in optional Options? options);

[Callback=FunctionOnly, NoInterfaceObject] interface SuccessCallback {
   void onsuccess();
};

[Callback=FunctionOnly, NoInterfaceObject] interface ErrorCallback {
   void onerror(in Error error);
};
</div>

<p>And could be used by developer as follows:</p>

<div id="container"><div><span class="signatureBlockTitle"><b>Function Only Success Callback - Optional error callback usage</b></span>
<pre class="examplecode prettyprint">
// The following calls are equivalent

fooOperation(handleSuccess(){alert("Operation Completed Successfully");},
             null, 
             null);

fooOperation(handleSuccess(){alert("Operation Completed Successfully");});

fooOperation(handleSuccess(){alert("Operation Completed Successfully");},
             null);
</pre>


<p>If the trailing arguments are not optional, the optional keyword cannot be included in the WebIDL definition and the possibility of having a null errorCallback should be described in the prose:</p>

<div id="container"><div><span class="signatureBlockTitle"><b>Function Only Success Callback - Optional ErrorCallback</b></span><pre class="webidl prettyprint">
/**
 * \brief Performs foo operation asynchronously.
 *
 * If any error occurs while attempting to add the event item, the errorCallback 
 * function that was passed in the invocation MUST be called.
 *
 * In any of the above cases where the errorCallback should be invoked, 
 * if the developer has not passed a valid ErrorCallback
 * (e.g. it is null or undefined), no action is required and the developer 
 * is not notified of the error.
 *
 * \param successCallback function called when the invocation ends successfully.
 * \param errorCallback function called when an error occurs.
 * \param options The options for the foo operation.
 */
void fooOperation(in SuccessCallback successCallback, 
                              in ErrorCallback? errorCallback, 
                              in DOMString selector);

[Callback=FunctionOnly, NoInterfaceObject] interface SuccessCallback {
   void onsuccess();
};

[Callback=FunctionOnly, NoInterfaceObject] interface ErrorCallback {
   void onerror(in Error error);
};
</div>

<p>And could be used by developer as follows:</p>

<div id="container"><div><span class="signatureBlockTitle"><b>Function Only Success Callback - Optional error callback usage</b></span>
<pre class="examplecode prettyprint">
// The following calls are equivalent

fooOperation(handleSuccess(){alert("Operation Completed Successfully");},
             null, 
             "argument");

fooOperation(handleSuccess(){alert("Operation Completed Successfully");},
             undefined, 
             "argument");
</pre>


<p>An alternative to having two callbacks could consist in having a single callback and pass a parameter that indicates success or failure as in the following example:</p>

<div id="container"><div><span class="signatureBlockTitle"><b>Function Only Success Callback - One function for both error and success</b></span><pre class="webidl prettyprint">
void fooOperation(in Callback callback, 
                              in Options options);

[Callback=FunctionOnly, NoInterfaceObject] interface Callback {
   void onsuccess(Response response);
};

</div>

<p>Such an API could be used as follows:</p>

<div id="container"><div><span class="signatureBlockTitle"><b>Function Only Success Callback - One function for both error and success usage</b></span>
<pre class="examplecode prettyprint">
fooOperation(handleResult(response){
                if (response.result === 0)
                  alert("Operation Completed Successfully");
                else
                  alert("Operation Failed");
             },
             {option1:0, option2:1000});
</pre>

<p>
This approach is discouraged in favour of having two different callback function as it:
<ul>
<li>
Allows a simpler successCallback function because it doesn't have to analyze the return code.
</li>
<li>
Emphasizes to the developer that he should implement error handling (e.g., the possibility that permission will be denied) by having a specific function for the error situation.
</li>
</ul>
</p>

</p>
</div> <!-- end section 3.1-->
<div class="section" lang="en">
<h3 class="title" style="clear: both;"><a name="interfacecallbacks"></a>3.2 - Interface Callbacks</h3>
<p>
In this approach, instead of using funtion(s) as input argument(s) for handling the callback an interface is passed. That interface is responsible for implementing the right methods that will handle the adequate callbacks. This approach will be used by Webinos APIs when not only the success and error events are needed, or when multiple results are expected from an operation. For instance, in WAC, this approach has been followed in order to receive success/error notifications for every recipient a SMS is sent to.
</p>

<div id="container"><div><span class="signatureBlockTitle"><b>Interface Callback Example</b></span><pre class="webidl prettyprint">
void foo(in InterfaceCallback callback, in Options options);

[Callback, NoInterfaceObject] interface MessageSendCallback {
   void onsuccess();
   void onerror(Error e);
   void onotherevent(DOMString event);
   void onindividualsuccess(in DOMString code);
   void onindividualerror(in Error e, in DOMString code);
};
</div>

<p> The first parameter of the asynchronous method is now an interface that specifies the different methods to be invoked for every notification and in case of final success.</p>

<div id="container"><div><span class="signatureBlockTitle"><b>Function Only Success Callback - One function for both error and success usage</b></span>
<pre class="examplecode prettyprint">
 // Define the interface callback
 var callback = {
       onsuccess: function() {
         alert("The full operation completed succesfully");},
       onindividualsuccess: function(code) {
         alert("The partial operation " + code " completed");},
       onindividualsuccess: function(e, code) {
         alert("The partial operation " + code " failed " + e.message);},
       onerror: function(e) {
         alert("At least one error ocurred " + e.message);}
 };
 
 // Send request
 foo(callback, {option1:0, option1:1000});
</pre>
 
<p>The advantage of this approach is that it is very flexible and extensible. However there are some drawbacks such as: </p>
<ul>
<li> It is more complex than the use of functions. It is not the typical JavaScript approach. </li>
<li> Checking the validity of the Interface may be complicated and difficult to be specified. E.g. What happens if the onsuccess method is not defined in the callback Interface?</li>
</ul>

</div>
</div> <!-- end of 3.2 -->


<div class="section" lang="en">
<h3 class="title" style="clear: both;"><a name="returnvalues"></a>3.3 - Asynchronous Methods Return Values</h3>
<p>
Asynchronous methods do not return the result of the operation directly but in the successCallback. When the method is executed it immediately returns with no result. WAC (and some W3C specs) have made asynchronous call to return a PendingOperation object, which may be used for emulating a syncrhonous call (by invoking a wait method) and for cancelling the asynchronous operation (by invoking a cancel method).
</p>
<p>
However, using a generic pending operation could have consistency issues as cancelling an operation may not be always possible and the expected behaviour of cancel operation may differ across different APIs.
</p>
<p> Webinos APIs will not use a generic pending operation interface. If any Webinos API needs to use such a feature, it will be defined by the API in order to provide a meaningful API specific meaning for the cancel operation.</p>
</div>

<div class="section" lang="en">
<h3 class="title" style="clear: both;"><a name="returnvalues"></a>3.4 - Using DOM Events instead of Asychronous Methods </h3>

<p>DOM events are an alternative for performing asynchronous operations instead of using callbacks. In some situations, where an object is also part of the DOM tree, DOM events could be used for asynchronous notifications. This approach allows developers to register event handlers as observers of the DOM tree.</p>
<p>This approach has been used by different W3C specifications such as the DeviceOrientation and the DAP BatteryStatus event.
</div>


<div class="section" lang="en">
<h2 class="title" style="clear: both;"><a name="errorhandling"></a>4 - Error Handling</h2>
<p>
Multiple JavaScript APIs use different schemas for identifying errors, the key differences amongst them being:
</p>
<ul>
<li>The class of the error objects: Standard ECMAScript Error, a class inheriting from Error, a new class for all the APIs, one class for API...
</li>
<li>The error codes: Centralized/Decentralized Error codes, Brand new ones, DOM Level 3 codes...
</ul>

Webinos APIs do not have a unique Error Object used by all the APIs. Different APIs create their own dedicated Error Objects. The API is also responsible for specifying the error codes that are required. Due to that, it is anticipated that the same error situation could lead to different error codes depending on the API used. 
<p>Webinos APIs do not have a unique Error interface used by all the APIs. Every API defines their own specialized Error class which includes their own specific error codes. This is approach that has been followed by W3C Geolocation and DAP. The error interface could be a brand new one or an interface extending the standard ECMAScript Error interface.</p>
<p>
As every API is the responsible for specifying its required error codes and no centralized error code repository is going to be used, it is anticipated that the same error situation could lead to different error codes depending on the API used. However, the webinos APIs will try to reuse the Error codes defined in DOM Level 3 specification are re-used whenever possible and extend if required regardless of the approach chosen from the ones described above </p>

<p> For instance, an API could use the following WebIDL definition for its Error interface </p>

<div id="container"><div><span class="signatureBlockTitle"><b>API Specific FooAPIError</b></span><pre class="webidl prettyprint">
 [NoInterfaceObject] interface FooAPIError {
    
    readonly attribute unsigned short code;
    
    readonly attribute DOMString message;
    
    const unsigned short      UNKNOWN_ERR                    = 0;
    const unsigned short      NOT_SUPPORTED_ERR              = 9;
    const unsigned short      TYPE_MISMATCH_ERR              = 17;
    const unsigned short      SECURITY_ERR                   = 18;
    const unsigned short      NETWORK_ERR                    = 19;
  };
</pre>
</div>
</div>


<p>The design choice for notifying about error situations to developers is different depending on the kind of method being launched (for simplicity FooAPIError object has been used in the examples).</p>


<div class="section" lang="en">
<h3 class="title" style="clear: both;"><a name=""></a>4.1 - Synchronous methods </h3>
<p>
When a synchronous method is executed all error conditions should be indicated by throwing an instance of the Error object (FooAPIError in the example) synchronously. These error conditions can be documented in WebIDL through the raises (FooAPIError) clause. The various error codes that may be returned in the exception (FooAPIException) instance are documented through the \throw doxygen tag in the widl documentation.</p>
<p> Interfaces to be thrown by methods should be declared in WebIDL through the <code>exception</code> keyword.</p>

<p>For instance, the following idl excerpt declares a synchronous function and the FooAPIException object as an exception.</p>
<div id="container"><div><span class="signatureBlockTitle"><b>Error Handling in Synchronous Method</b></span><pre class="webidl prettyprint">
/*
 * \brief The FooAPIException
 */
exception FooAPIException{

  readonly attribute unsigned short code;

  readonly attribute DOMString message;

  const unsigned short FOO1_ERR = 0;
  const unsigned short FOO2_ERR = 0;
}


/*
 * \brief the syncrhonous foo method
 * \param fooShort The operation code.
 *
 * \throw FooAPIException with error code FOO2_ERR if foo2 occurs. 
 * \throw FooAPIException with error code FOO1_ERR if foo1 occurs. 
 */
void foo(in short fooShort)
                      raises(FooAPIException);
</div>
<p>The throw clause are converted by the webinos documentation toolchain into HTML code, for instance:</p>
<div>
<i><code>
<h5>Exceptions</h5>
<ul>
          <li class="exception">FooAPIException:
        <div class="description"><p>
 with error code FOO1_ERR if foo1 occurs. 
                </p></div>
<div class="description"><p>
 with error code FOO2_ERR if foo2 occurs. 
                </p></div>
</li>
</ul>
</code></i>
</div>

<div class="section" lang="en">
<h3 class="title" style="clear: both;"><a name=""></a>4.2 - Asynchronous methods </h3>
<p>When an asynchronous method is executed, all the errors should be returned in the errorCallback or in the interface that was passed as input argument (see section 3 for more details).</p>

<p>However, before starting the asynchronous phase of the operation, methods cannot return errors in the ErrorCallback. This is usually the case for the situations in which the arguments provided are not of the expected type. In those situations, the error should be thrown rather than returned in the ErrorCallback.</p>

<p>The preferred behaviour in Webinos APIs is checking first that the arguments are of the valid type or can be coerced to the appropriate type. If one or more arguments are passed whose type is incompatible with the declared type of that argument, the method will raise a FooAPIException synchronously with the appropriate code (e.g. code TYPE_MISMATCH_ERR). Any other error will be returned in the ErrorCallback that was passed as input argument to the asynchronous function as a FooAPIError, the documentation of the method will specify which codes and under which conditions the error will be returned in the ErrorCallback. If no error callback is passed or it is null or undefined, no additional notification is needed (i.e. the method fails silently).</p>

<p>Type conversions between the supplied arguments and the declared IDL argument type are performed in accordance with the ECMAScript WebIDL binding.</p>

<p>The following is a WebIDL excerpt declaring an asynchronous method</p>

<div id="container"><div><span class="signatureBlockTitle"><b>Error Handling in Asynchronous Methods</b></span><pre class="webidl prettyprint">

/*
 * \brief The FooAPIException
 */
exception FooAPIException : FooAPIError{

}

/*
 * \brief The FooAPIError
 */
exception FooAPIError{

  readonly attribute unsigned short code;

  readonly attribute DOMString message;

  const unsigned short FOO1_ERR = 0;
  const unsigned short FOO2_ERR = 1;
  const unsigned short TYPE_MISMATCH_ERR = 2;
}

/*
 * \brief the synchronous foo method
 * \param fooShort The operation code.
 *
 * \throw FooAPIException with error code TYPE_MISMATCH_ERR if the input parameter 
 * is not compatible with the expected type for that parameter.
 */
void foo(in SuccessCallback successCallback, 
         in ErrorCallback? errorCallback, 
         in Options options)
         raises(FooAPIException);
</div>
<p>
The raises(FooAPIException) part is intended to specify that although the method is asynchronous, a FooAPIException may be thrown if the arguments are not of the valid type (TYPE_MISMATCH_ERR). That is documented in the method exception list as in the case of the synchronous calls:</p>

<p>
<i><code>
<h5>Exceptions</h5>
<ul>
          <li class="exception">FooAPIException:
        <div class="description"><p>
 with error code TYPE_MISMATCH_ERR if any input parameter 
is not compatible with the expected type for that parameter.
                </p></div>
</li>
</ul>
</code></i>
</p>

<p>
The errors returned in the errorCallback are also specified in the method description as in the following WebIDL.
</p>

<div id="container"><div><span class="signatureBlockTitle"><b>Error Handling in Asynchronous Methods</b></span><pre class="webidl prettyprint">
/*
 * \brief the syncrhonous foo method
 *
 * When the operation is fully completed the onsuccess method of
 * the successCallback. Otherwise, the errorCallback will be invoked with an appropriate
 * error code amongst the following:
 * &lt;ul&gt;
 * &lt;li&gt;
 *  FOO1: If foo1 error occurs.
 * &lt;li&gt;
 *  FOO2: If foo2 error occurs. 
 * &lt;li&gt;
 * &lt;li&gt;
 * &lt;ul&gt;
 * \param fooShort The operation code.
 *
 * \throw FooAPIException with error code TYPE_MISMATCH_ERR if the input parameter 
 * is not compatible with the expected type for that parameter.
 */
void foo(in SuccessCallback successCallback, 
         in ErrorCallback? errorCallback, 
         in Options options)
         raises(FooAPIException);
</div>
<p> That will generate the following documentation through the toolchain: </p>
<p><i><code>
When the operation is fully completed the onsuccess method of
the successCallback. Otherwise, the errorCallback will be invoked with an FooAPIError with an appropriate
error code amongst the following:
            </p>
            <ul>
              <li>
 FOO1: If foo1 error occurs.               </li>
              <li>
 FOO2: If foo1 error occurs.               </li>
            </ul>

</code></i></p>

<div class="section" lang="en">
<h3 class="title" style="clear: both;"><a name=""></a>4.3 - Usage Examples</h3>

<pre name="code" class="examplecode prettyprint"> 
foo("notACallback", 
            checkError(e){alert("An error with code " + e.code + " occurred"}, 
            options);
</pre>

<p>This invocation will raise an exception with code TYPE_MISMATCH_ERR as "notACallback" cannot be coerced to an interface.</p>

<div class="example">
<pre name="code" class="examplecode prettyprint"> 
foo(null, 
            checkError(e){alert("An error with code " + e.code + " occurred"}, 
            options);
</pre></div>
<p>As the successCallback is null, the method will return in the error callback the appropriate error code.</p>

<div class="example">
<pre name="code" class="examplecode prettyprint"> 
foo(success(){alert("Foo exec")}, 
            "notACallback", 
            options);
</pre></div>
<p>This invocation will raise an FooAPIException with code TYPE_MISMATCH_ERR as "notACallback" cannot be coerced to an interface.</p>

<div class="example">
<pre name="code" class="examplecode prettyprint"> 
foo(success(){alert("Foo executed")}, 
            null, 
            options);
</pre></div>
<p>As the errorCallback is null, the method will execute and if completed successfully the successCallback will be invoked. If the method is unsuccessfully executed, it would silently fail.</p>

<div class="example">
<pre name="code" class="examplecode prettyprint"> 
foo(success(){alert("Foo executed")}, 
            checkError(e){alert("An error with code " + e.code + " occurred"}, 
            options);
</pre></div>
<p>The method will execute and if completed successfully the successCallback will be invoked. If the method is unsuccessfully executed, the errorCallback will be invoked with an appropriate error code.</p>

<div>
<h2 class="title" style="clear: both;"><a name="optionalnullable"></a>5 - Optional, Nullable and Valid Arguments</h2>

<p>WebIDL provides a mechanism to document that an argument is optional. In order to so, the keyword optional must be included just before the argument type. All the optional arguments that are used in Webinos APIs are marked with that keyword.</p>

<p>E.g. the following WebIDL excerpt specifies that the second and third input arguments is optional.</p>
<div id="container"><div><span class="signatureBlockTitle"><b>Optional Arguments</b></span><pre class="webidl prettyprint">
    void foo(in SuccessCallback successCallback, 
             in optional ErrorCallback errorCallback,
             in optional Options options)
         raises (FooAPIException); 
</div>
<p>Optional arguments must be always in the last position of the argument list. E.g. There cannot be a non-optional after an optional argument. Optional arguments may be omitted by the Developers. For instance, both calls of the method foo are valid:</p>

<div class="example">
<pre name="code" class="examplecode prettyprint"> 
  foo(function(){alert("Operation completed")});
  foo(function(){alert("Operation completed")}, 
                                  errorHandler(e){"Error occured";});
  foo(function(){alert("Operation completed")}, 
                                  errorHandler(e){"Error occured";}, 
                                  {fooparam1:10000});
</div>
<p>If an optional argument has not the appropriate type or cannot be coerced to it, the recommendation is that the method throws an error with a TYPE_MISMATCH_ERR code as explained in previous section. E.g.</p>

<div class="example">
<pre name="code" class="examplecode prettyprint"> 
foo(function(){alert("Operation completed")}, 
                        "this is an invalidFunction");
</div>

<p>The second argument cannot be coerced to the expected type (function).</p>

<p>It should be specified what happens when an optional argument contains an invalid value, although of the right type. The recommendation is that a specific error is returned in those cases (e.g. an INVALID_VALUES_ERR) or throw it if it is synchronous unless a different behaviour is required.</p>

<p>A nullable input argument is identified by the '?' character that is suffixed to the Data Type. This character can be used for Primitive EcmaScript Data Types and for derived ones. As undefined is coerced to null, the same behaviour with regards to null and undefined are expected for any input argument of an interface (derived) type declared as nullable.</p>

<p>For primitive types, consider the following WebIDL declaration:</p>
<div id="container"><div><span class="signatureBlockTitle"><b>Optional and Nullable primitive type arguments</b></span><pre class="webidl prettyprint">
void foo(in DOMString mandatoryArgument, 
         [TreatUndefinedAs=Null] in optional DOMString? optionalArgument)
</div>
<p>The following calls are valid and equivalent (the last argument can be ommitted (is optional) and can be null (is nullable)).</p>

<div class="example">
<pre name="code" class="examplecode prettyprint"> 
foo("mandated", null);
foo("mandated");
</div>

<p>For interface types, consider the following WebIDL declaration:</p>

<div id="container"><div><span class="signatureBlockTitle"><b>Optional and Nullable interface type arguments</b></span><pre class="webidl prettyprint">

void foo(in SuccessCallback successCallback, 
         in optional ErrorCallback? errorCallback,
         in optional Options? options)
         raises (FooAPIException);
</div>
<p>The following invocations are all valid and equivalent:</p>

<div class="example">
<pre name="code" class="examplecode prettyprint"> 
  foo(f(){alert("Success")});
  foo(f(){alert("Success")}, null);
  foo(f(){alert("Success")}, null, null);
</div>

<p>Obviously, in all the cases above no options are passed to the function and in case of any error no notification is sent back to the developer.</p>

<p>It has been mentioned that coercion is used to check if an input argument is of the valid type. ECMAScript is a loosely typed language, and hence some assumptions that may be true for other programming languages are not valid in ECMAScript. Additionally the rules specified by WebIDL spec around Types must also be taken into account.</p>

<p>For instance, for the following WebIDL declaration:</p>
<div id="container"><div><span class="signatureBlockTitle"><b>Coercion</b></span><pre class="webidl prettyprint">
    void foo(in long watchId)
             raises (FooAPIException);
</div>
<p>The call <code>foo("Notalong");</code> will not throw a TYPE_MISMATCH_ERR as "Foo" can be coerced to NaN (Not an number) wich is a valid instance of long primitive type.</p>
</div>

</body>
